[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantitative Methoden",
    "section": "",
    "text": "Diese Website dient als Sammlung meiner Vorlesungsnotizen und Übungen für die Vorlesung “Quantitative Methoden” im Herbstsemester 2024.\nDiese Sammlung ist aktuell noch am Entstehen.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Inhalte dieser Website können Lücken und Fehler enthalten. Die Inhalte werden laufend ergänzt und verbessert.\nFehler und Vorschläge können auf jeder Seite direkt über Problem melden auf Github gemeldet werden. Bitte das entsprechende Issue-Template verwenden.\nFalls bereits Erfahrung mit Github und quarto besteht, kann auch jeweils direkt die Seite bearbeitet werden. Anschliessend kann ein Pull-Request erstellt werden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Übersicht</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html",
    "href": "grundlagen_R.html",
    "title": "2  Grundlagen R",
    "section": "",
    "text": "3 Grundlagen R",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#grundsätzliches-zu-r",
    "href": "grundlagen_R.html#grundsätzliches-zu-r",
    "title": "2  Grundlagen R",
    "section": "3.1 Grundsätzliches zu R",
    "text": "3.1 Grundsätzliches zu R\n\n3.1.1 Zuweisungsoperator\nIn R werden Werte Variablen mit dem &lt;- Operator zugewiesen.\n\n# Variablen erstellen und Wert zuweisen\na &lt;- 5\n\n# Die Zuweisung kann auch umgekehrt erfolgen\n5 -&gt; b\n\n# Das gleiche funktioniert grundsätzlich aber auch mit dem = Operator\n# Allerdings wird der &lt;- Operator bevorzugt\nc = 10\n\n\n\n3.1.2 Kommentare\nKommentare in R werden mit einem # eingeleitet. Sie können entweder in einer eigenen Zeile stehen oder am Ende einer Codezeile.\n\n# Das ist ein Kommentar\na &lt;- 5 # Das ist auch ein Kommentar\n\n\n\n3.1.3 Ausgabe\nIn R können Werte entweder mit der print() Funktion oder einfach durch Eingabe des Variablennamens ausgegeben werden.\n\n# Ausgabe von Variablen\nprint(a)\n\n[1] 5\n\nb\n\n[1] 5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#datentypen",
    "href": "grundlagen_R.html#datentypen",
    "title": "2  Grundlagen R",
    "section": "3.2 Datentypen",
    "text": "3.2 Datentypen\nIn R gibt es verschiedene Datentypen. Die wichtigsten sind:\n\nNumerische Werte (z.B. 5, 3.14)\nZeichenketten (Strings) (z.B. \"Hallo Welt\")\nLogische Werte (TRUE, FALSE)\nVektoren (in Python Listen) (z.B. c(1, 2, 3))1\nData Frames (ähnlich wie Tabellen, Mischen von Datentypen möglich)\nMatrizen (ähnlich wie in der Mathematik, keine Mischung von Datentypen möglich)\n\n\n3.2.1 Vektoren\nDa Vektoren eine der grundlegenden Datenstrukturen in R sind, werden wir uns diese genauer ansehen.\nSie können mit der c() Funktion erstellt werden. Vektoren sind grundsätzlich ähnlich wie Objekte vom Typ list in Python. Vektoren können sämtliche Datentypen enthalten, jedoch nur einen Datentyp pro Vektor.\nAuf Vektoren können verschiedene Operationen durchgeführt werden, wie z.B. Addition, Subtraktion, Multiplikation, Division, etc.\n\n# Vektor erstellen\nvectorA &lt;- c(1, 2, 3, 4, 5)\n\n# Länge des Vektors\nlength(vectorA)\n\n[1] 5\n\n# Logischer Vergleich\nvectorA &gt;= 3\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n# Arithmetische Operationen\nvectorA + 5\n\n[1]  6  7  8  9 10\n\n\nWenn wir nun den Vektor vectorA erneut ausgeben, beobachten wir, dass die Operationen nicht den ursprünglichen Vektor verändert haben.\n\nvectorA\n\n[1] 1 2 3 4 5\n\n\nUm den Vektor zu verändern, müssen wir den veränderten Vektor entweder einer neuen Variablen zuweisen oder den Vektor direkt überschreiben.\n\n# Vektor einer neuen Variablen zuweisen\nvectorB &lt;- vectorA + 5\n\n# Vektor ausgeben\nvectorB\n\n[1]  6  7  8  9 10\n\n# Wir können den Vektor auch direkt überschreiben\nvectorA &lt;- vectorA + 5\n\n# Vektor ausgeben\nvectorA\n\n[1]  6  7  8  9 10\n\n\n\n3.2.1.1 Indizierung\nVektoren können indiziert werden, um auf bestimmte Elemente zuzugreifen.\nDie Indizierung beginnt in R bei 1.\n\n# Erstes Element des Vektors\nvectorA[1]\n\n[1] 6\n\n\nWir können auch auf mehrere Elemente gleichzeitig zugreifen. Wenn wir z.B. auf das zweite bis vierte Element des Vektors zugreifen wollen, können wir dies mit dem : Operator tun.\n\n# Zweites bis viertes Element des Vektors\nvectorA[2:4]\n\n[1] 7 8 9\n\n# Alternativ können wir auch einzelne Elemente überspringen\nvectorA[c(1, 3, 5)]\n\n[1]  6  8 10\n\n\n\n\n3.2.1.2 Vektoren konkatenieren\nVektoren können auch konkateniert werden.\n\n# Vektoren erstellen\nvectorA &lt;- c(1, 2, 3, 4, 5)\n\n# Vektoren konkatenieren\nvectorC &lt;- c(vectorA, vectorB)\n\n# Vektor ausgeben\nvectorC\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n3.2.1.3 Vektoren addieren\nVektoren können auch addiert werden. Hierbei werden die Vektoren elementweise addiert.2\n\n# Vektoren addieren\nvectorA + vectorB\n\n[1]  7  9 11 13 15\n\n\n\n\n3.2.1.4 Wichtige Funktionen für Vektoren\n\n\n\n\n\n\n\n\n\nFunktion\nBeschreibung\nBeispiel\nAusgabe\n\n\n\n\nlength()\nLänge des Vektors\nlength(vectorA)\n5\n\n\nsum()\nSumme der Elemente des Vektors\nsum(vectorA)\n15\n\n\nmean()\nDurchschnitt der Elemente des Vektors\nmean(vectorA)\n3\n\n\nvar()\nVarianz der Elemente des Vektors\nvar(vectorA)\n2.5\n\n\nsd()\nStandardabweichung der Elemente des Vektors\nsd(vectorA)\n1.5811388\n\n\nmin()\nMinimum des Vektors\nmin(vectorA)\n1\n\n\nmax()\nMaximum des Vektors\nmax(vectorA)\n5\n\n\nrange()\nBereich des Vektors\nrange(vectorA)\n1, 5\n\n\n\n\n\n\n3.2.2 Data Frames\nIn Data Frames können Vektoren unterschiedlicher Datentypen kombiniert werden. Sie sind ähnlich wie Tabellen in relationalen Datenbanken.\nData Frames können mit der data.frame() Funktion direkt erstellt werden.\n\n# Data Frame erstellen\ndataFrameA &lt;- data.frame(\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\"),\n  age = c(25, 30, 35, 40),\n  married = c(TRUE, FALSE, TRUE, TRUE)\n)\n\n# Data Frame ausgeben\ndataFrameA\n\n     name age married\n1   Alice  25    TRUE\n2     Bob  30   FALSE\n3 Charlie  35    TRUE\n4   David  40    TRUE\n\n\nWichtig ist, dass die Vektoren, die im Data Frame kombiniert werden sollen, die gleiche Länge haben müssen und dass die Vektoren nur einen Datentyp pro Vektor enthalten dürfen.\nWir beobachten auch hier, dass die Vektoren in der Initialisierung des Data Frames wieder mit der c() Funktion erstellt werden.\n\n3.2.2.1 Indizierung\nData Frames können indiziert werden, um auf bestimmte Elemente zuzugreifen.\nDie Indizierung erfolgt ähnlich wie bei Vektoren, jedoch mit dem Unterschied, dass wir zusätzlich auch die gewünschte Spalte angeben müssen. Dies erfolgt durch die Angabe der Zeilen- und Spaltennummer in eckigen Klammern.\nWenn wir eine ganze Zeile ausgeben wollen, geben wir nur die Zeilennummer an und lassen die Spaltennummer weg.\n\n# Erste Zeile des Data Frames\ndataFrameA[1, ]\n\n   name age married\n1 Alice  25    TRUE\n\n# Zweite Zeile und dritte Spalte des Data Frames\ndataFrameA[2, 3]\n\n[1] FALSE\n\n\nWir können mit dem $ Operator auch direkter auf bestimmte Spalten zugreifen.\n\n# Spalte \"name\" des Data Frames\ndataFrameA$name\n\n[1] \"Alice\"   \"Bob\"     \"Charlie\" \"David\"  \n\n\n\n\n3.2.2.2 Auswahl aus Data Frames wieder als Data Frame\nWir können subsetting verwenden, um einen Teil des Data Frames auszuwählen und diesen wieder als Data Frame zu speichern.\n\n# Auswahl der Spalten \"name\" und \"age\" als Data Frame\ndataFrameB &lt;- dataFrameA[, c(\"name\", \"age\")]\n\n# Data Frame ausgeben\ndataFrameB\n\n     name age\n1   Alice  25\n2     Bob  30\n3 Charlie  35\n4   David  40\n\n\n\n\n3.2.2.3 Wichtige Funktionen für Data Frames\n\n\n\n\n\n\n\n\n\nFunktion\nBeschreibung\nBeispiel\nAusgabe\n\n\n\n\nnrow()\nAnzahl der Zeilen des Data Frames\nnrow(dataFrameA)\n4\n\n\nncol()\nAnzahl der Spalten des Data Frames\nncol(dataFrameA)\n3\n\n\ncolnames()\nSpaltennamen des Data Frames\ncolnames(dataFrameA)\nname, age, married\n\n\nrownames()\nZeilennamen des Data Frames\nrownames(dataFrameA)\n1, 2, 3, 4\n\n\nsummary()\nZusammenfassung des Data Frames\nsummary(dataFrameA)\nLength:4 , Class :character , Mode :character , NA, NA, NA, Min. :25.00 , 1st Qu.:28.75 , Median :32.50 , Mean :32.50 , 3rd Qu.:36.25 , Max. :40.00 , Mode :logical , FALSE:1 , TRUE :3 , NA, NA, NA",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#daten-importieren-und-exportieren",
    "href": "grundlagen_R.html#daten-importieren-und-exportieren",
    "title": "2  Grundlagen R",
    "section": "3.3 Daten importieren und exportieren",
    "text": "3.3 Daten importieren und exportieren\nIn R können Daten aus verschiedenen Dateiformaten importiert und exportiert werden. Dazu gehören z.B. CSV-Dateien, Excel-Dateien, JSON-Dateien, etc.\n\n3.3.1 CSV-Dateien\nCSV-Dateien können mit der read.csv() Funktion in R eingelesen werden.\n\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv', sep = ',', header = TRUE)\n\nIn diesem Beispiel wird die CSV-Datei meteodaten_saison.csv eingelesen. Der Parameter sep = ',' gibt an, dass die Werte in der CSV-Datei durch Kommas getrennt sind. Der Parameter header = TRUE gibt an, dass die erste Zeile der CSV-Datei die Spaltennamen enthält.\n\n\n\n\n\n\nAchtung\n\n\n\nDer Pfad zur Datei muss entweder absolut (Bsp.: C:/Users/username/Documents/data.csv) oder relativ zum aktuellen Arbeitsverzeichnis (Bsp.: Data/data.csv) angegeben werden.\nIn aller Regel ist es sinnvoll, den Pfad relativ zum aktuellen Arbeitsverzeichnis anzugeben. Das aktuelle Arbeitsverzeichnis kann in der Terminalkonsole mit dem Befehl getwd() abgefragt werden, und mit dem Befehl setwd() kann das Arbeitsverzeichnis geändert werden.\nEine gängige (und hier angewandte) Praxis ist es, ein Unterverzeichnis Data im Projektverzeichnis anzulegen und dort alle Daten abzulegen.\nDer einfachste Weg ist es im Explorer einen Ordner anzulegen in welchem alle Skripte gespeichert werden. In diesem Ordner kann dann ein Unterordner Data erstellt werden, in welchem die Daten abgelegt werden.\nIn RStudio kann das Arbeitsverzeichnis über das Menü Session -&gt; Set Working Directory -&gt; Choose Directory... gesetzt werden.\n\n\n\n3.3.1.1 Wichtige Funktionen für Datenimport\n\n\nstr(): Zeigt die Struktur des Data Frames an.\n\n\nstr(meteodaten)\n\n'data.frame':   492 obs. of  6 variables:\n $ Jahr                           : int  1901 1901 1901 1901 1902 1902 1902 1902 1903 1903 ...\n $ Saison                         : chr  \"Fruehling(MAM)\" \"Herbst(SON)\" \"Sommer(JJA)\" \"Winter(DJF)\" ...\n $ Bern_Mitteltemperatur          : num  7.73 7.4 16.8 -2.73 7.53 ...\n $ Bern_Niederschlagssumme        : num  278 245 381 112 323 ...\n $ GrStBernhard_Mitteltemperatur  : num  -4 -0.8 6.3 -10.6 -3.63 ...\n $ GrStBernhard_Niederschlagssumme: num  495 521 285 356 448 ...\n\n\n\n\n\nhead(): Zeigt die ersten Zeilen des Data Frames an.\n\n\nhead(meteodaten)\n\n  Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n1 1901 Fruehling(MAM)              7.733333                   277.8\n2 1901    Herbst(SON)              7.400000                   244.9\n3 1901    Sommer(JJA)             16.800000                   381.1\n4 1901    Winter(DJF)             -2.733333                   112.4\n5 1902 Fruehling(MAM)              7.533333                   323.2\n6 1902    Herbst(SON)              7.466667                   231.7\n  GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n1                     -4.000000                           494.7\n2                     -0.800000                           520.8\n3                      6.300000                           285.2\n4                    -10.600000                           356.2\n5                     -3.633333                           448.1\n6                     -1.000000                           335.6\n\n\n\n\n\ntail(): Zeigt die letzten Zeilen des Data Frames an.\n\n\ntail(meteodaten)\n\n    Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n487 2022    Sommer(JJA)             20.000000                   238.3\n488 2022    Winter(DJF)              2.233333                   184.7\n489 2023 Fruehling(MAM)              9.533333                   272.5\n490 2023    Herbst(SON)             11.966667                   371.2\n491 2023    Sommer(JJA)             20.000000                   203.1\n492 2023    Winter(DJF)              2.700000                   233.1\n    GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n487                     10.266667                           256.8\n488                     -4.966667                           270.0\n489                     -1.666667                           388.4\n490                      2.966667                           553.3\n491                      9.200000                           288.4\n492                     -5.333333                           228.7\n\n\n\n\n\nsummary(): Gibt eine Zusammenfassung des Data Frames aus.\n\n\nsummary(meteodaten)\n\n      Jahr         Saison          Bern_Mitteltemperatur\n Min.   :1901   Length:492         Min.   :-4.500       \n 1st Qu.:1931   Class :character   1st Qu.: 4.883       \n Median :1962   Mode  :character   Median : 8.750       \n Mean   :1962                      Mean   : 8.715       \n 3rd Qu.:1993                      3rd Qu.:12.750       \n Max.   :2023                      Max.   :21.100       \n Bern_Niederschlagssumme GrStBernhard_Mitteltemperatur\n Min.   : 47.9           Min.   :-11.2000             \n 1st Qu.:185.7           1st Qu.: -5.1000             \n Median :243.2           Median : -1.4000             \n Mean   :253.3           Mean   : -0.9232             \n 3rd Qu.:308.9           3rd Qu.:  3.2750             \n Max.   :600.1           Max.   : 10.5333             \n GrStBernhard_Niederschlagssumme\n Min.   : 125.9                 \n 1st Qu.: 383.1                 \n Median : 491.5                 \n Mean   : 513.9                 \n 3rd Qu.: 619.2                 \n Max.   :1351.6                 \n\n\n\n\n\nIndizierung: Mit der Indizierung können bestimmte Zeilen und Spalten des Data Frames ausgewählt werden.\n\n\nmeteodaten[1:10,] # Ersten 10 Zeilen\n\n   Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n1  1901 Fruehling(MAM)              7.733333                   277.8\n2  1901    Herbst(SON)              7.400000                   244.9\n3  1901    Sommer(JJA)             16.800000                   381.1\n4  1901    Winter(DJF)             -2.733333                   112.4\n5  1902 Fruehling(MAM)              7.533333                   323.2\n6  1902    Herbst(SON)              7.466667                   231.7\n7  1902    Sommer(JJA)             16.466667                   295.9\n8  1902    Winter(DJF)             -0.800000                   193.9\n9  1903 Fruehling(MAM)              7.433333                   177.6\n10 1903    Herbst(SON)              8.766667                   267.3\n   GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n1                     -4.0000000                           494.7\n2                     -0.8000000                           520.8\n3                      6.3000000                           285.2\n4                    -10.6000000                           356.2\n5                     -3.6333333                           448.1\n6                     -1.0000000                           335.6\n7                      5.3000000                           242.7\n8                     -7.4000000                           341.2\n9                     -4.4666667                           409.7\n10                    -0.4666667                           507.1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#daten-als-.csv--und-.txt-dateien-exportieren",
    "href": "grundlagen_R.html#daten-als-.csv--und-.txt-dateien-exportieren",
    "title": "2  Grundlagen R",
    "section": "3.4 Daten als .csv- und .txt-Dateien exportieren",
    "text": "3.4 Daten als .csv- und .txt-Dateien exportieren\nDaten können mit der write.csv() Funktion als CSV-Dateien und mit der write.table() Funktion als Textdateien exportiert werden.\n\n3.4.1 .csv-Dateien\n\n# CSV-Datei exportieren\nwrite.csv(meteodaten,\n          file = \"meteodaten.csv\",\n          row.names = FALSE)\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nx\nDas Data Frame, das exportiert werden soll.\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden.\n\n\nrow.names\nGibt an, ob die Zeilennummern in der CSV-Datei gespeichert werden sollen.\n\n\n\n\n\n3.4.2 .txt-Dateien\n\n# Textdatei exportieren\nwrite.table(meteodaten, # Das Data Frame, das exportiert werden soll\n            file = \"meteodaten.txt\", # Dateiname und Speicherort\n            sep = \"\\t\", # Tabulator als Trennzeichen\n            eol = \"\\r\", # Zeilenumbruch\n            na = \"NA\", # Wert für fehlende Daten\n            row.names = FALSE,\n            col.names = TRUE)\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nx\nDas Data Frame, das exportiert werden soll.\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden.\n\n\nsep\nTrennzeichen für die Spalten.\n\n\neol\nZeilenumbruch. Kann je nach Betriebssystem erforderlich sein.\n\n\nna\nWert für fehlende Daten.\n\n\nrow.names\nGibt an, ob die Zeilennummern in der Textdatei gespeichert werden sollen.\n\n\ncol.names\nGibt an, ob die Spaltennamen in der Textdatei gespeichert werden sollen.\n\n\n\nWie sonst auch, haben die meisten Parameter Standardwerte, die nicht explizit angegeben werden müssen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#umgang-mit-fehlwerten",
    "href": "grundlagen_R.html#umgang-mit-fehlwerten",
    "title": "2  Grundlagen R",
    "section": "3.5 Umgang mit Fehlwerten",
    "text": "3.5 Umgang mit Fehlwerten\nFehlwerte sind in Datenanalysen ein häufiges Problem. In R werden Fehlwerte standardmässig mit NA (Not Available) dargestellt.\n\n3.5.1 Fehlwerte in Funktionsaufrufen behandeln\nErstellen wir ein Beispiel-Vektor mit Fehlwerten:\n\nvektor_mit_na &lt;- c(1, 2, NA, 4, 5)\n\nWenn wir nun z.B. die Summe des Vektors berechnen, erhalten wir:\n\nsum(vektor_mit_na)\n\n[1] NA\n\n\nDie Ausgabe ist NA, da R nicht weiss, wie es mit dem Fehlwert umgehen soll.\nWir können in diversen Funktionen definieren, wie mit Fehlwerten umgegangen werden soll. Dazu können wir den na.rm Parameter verwenden. (rm = remove) Dieser Parameter ist standardmässig auf FALSE gesetzt.\n\nsum(vektor_mit_na,\n    na.rm = TRUE)\n\n[1] 12\n\n\nDie Ausgabe ist 12, da der Fehlwert ignoriert wird.\nDies funktioniert auch bei anderen Funktionen, wie z.B. mean(), var(), sd(), etc.\n\n\n3.5.2 Fehlwerte im Dateiimport behandeln\nBeim Import von Daten können wir mit dem Parameter na.strings definieren, welche Werte als Fehlwerte interpretiert werden sollen.\n\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv',\n                        sep = ',',\n                        header = TRUE,\n                        na.strings = c(\"NA\", \"N/A\", \"na\"))\n\nIn diesem Beispiel definieren wir, dass die Werte \"NA\", \"N/A\" und \"na\" als Fehlwerte interpretiert werden sollen.\n\n\n3.5.3 Fehlwerte identifizieren\nFehlwerte können mit der is.na() Funktion identifiziert und mit der na.omit() Funktion entfernt werden.\n\n# Fehlwerte identifizieren\nis.na(vektor_mit_na)\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n# Fehlwerte entfernen\nvektor_ohne_na &lt;- na.omit(vektor_mit_na)\n\nDer Vektor ist nun: 1, 2, 4, 5.\n\n3.5.3.1 Überprüfen auf Gleichheit\nFehlwerte müssen mit is.na() überprüft werden, da sie nicht mit == verglichen werden können.3\n\n# Überprüfen auf Gleichheit\nvektor_mit_na == NA\n\n[1] NA NA NA NA NA\n\n# Überprüfen auf Gleichheit mit is.na()\nis.na(vektor_mit_na)\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n\n\n\n\n3.5.4 Fehlwerte ersetzen\nMit der replace() Funktion können Fehlwerte am einfachsten ersetzt werden.\n\n# Vector mit falschen Fehlwerten\nvektor_mit_falschen_na &lt;- c(1, 2, -999, 4, 5)\n\n# Fehlwerte ersetzen\nvektor_mit_korrigierten_na &lt;- replace(vektor_mit_falschen_na,\n                                      vektor_mit_falschen_na == -999,\n                                      NA)\n\nDer Vektor ist nun: 1, 2, NA, 4, 5.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#übungen",
    "href": "grundlagen_R.html#übungen",
    "title": "2  Grundlagen R",
    "section": "3.6 Übungen",
    "text": "3.6 Übungen\nBerechne die Sommer (JJA) Temperaturanomalien zur Referenzperiode 1961 bis 1990 in Bern.\n\n# Daten einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv', sep = ',', header = TRUE)\n\n# Daten filtern\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\n\n# Referenzwert der Periode 1961 bis 1990 berechnen\nreferenzwert &lt;- mean(\n    saison_sommer$Bern_Mitteltemperatur[saison_sommer$Jahr &gt;= 1961\n    & saison_sommer$Jahr &lt;= 1990])\n\n# Sommer (JJA) Temperaturanomalien berechnen und direkt im data frame speichern\nsaison_sommer$Bern_Mitteltemperatur_anomalie &lt;-\n    saison_sommer$Bern_Mitteltemperatur - referenzwert\n\n# Plot erstellen\nplot(saison_sommer$Jahr,\n    saison_sommer$Bern_Mitteltemperatur_anomalie,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Temperaturanomalie (°C)\",\n    main = \"Sommer (JJA) Temperaturanomalien in Bern\")\n\n# null-Linie hinzufügen\nabline(h = 0, col = \"red\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#footnotes",
    "href": "grundlagen_R.html#footnotes",
    "title": "2  Grundlagen R",
    "section": "",
    "text": "Kleine Anmerkung: Hier wird der Vektor mit der c() Funktion erstellt. Diese Funktion wird verwendet, um Werte zu kombinieren (combine).↩︎\nWenn die Vektoren unterschiedliche Längen haben, wird der kürzere Vektor so oft wiederholt, bis er die Länge des längeren Vektors hat. Wenn die Länge des längeren Vektors kein Vielfaches der Länge des kürzeren Vektors ist, wird eine Warnung ausgegeben.↩︎\nDer Vergleich von Fehlwerten mit == ergibt immer NA, da R nicht weiss, ob der Fehlwert gleich einem anderen Wert ist oder nicht.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html",
    "href": "plots_in_R.html",
    "title": "3  Einfache Plots erstellen",
    "section": "",
    "text": "4 Einfache Plots erstellen\n“High-level” Plots können in R mit der plot() Funktion erstellt werden. Diese Funktion erstellt automatisch für die gegebenen Daten ein (geeignetes) Diagramm.\nWenn wir aber Beispielsweise unser ganzes meteodaten Data Frame plotten wollen, weiss die Funktion nicht, wie sie das tun soll und plottet einfach alle Spalten gegen alle anderen Zeilen. Dies ist in diesem Fall nicht sinnvoll.\nplot(meteodaten)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#liniendiagramme",
    "href": "plots_in_R.html#liniendiagramme",
    "title": "3  Einfache Plots erstellen",
    "section": "4.1 Liniendiagramme",
    "text": "4.1 Liniendiagramme\nUm unsere Daten sinnvoller zu plotten müssen wir die Daten zuerst filtern und dann plotten.\nWir diskutieren die verschiedenen Schritte hier später:\n\n# Subsets der Daten erstellen\nsaison_fruehling &lt;- meteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\nsaison_herbst &lt;- meteodaten[meteodaten$Saison == \"Herbst(SON)\", ]\nsaison_winter &lt;- meteodaten[meteodaten$Saison == \"Winter(DJF)\", ]\n\n# Plot mit den Saisontemperaturen erstellen erstellen\nplot(saison_fruehling$Jahr, saison_fruehling$Bern_Mitteltemperatur,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Saisonale Durchschnittstemperaturen in Bern\",\n    xlim = c(1900, 2020),\n    ylim = c(-5, 35))\n\n# Weitere Linien für andere Jahreszeiten auf den selben Plot hinzufügen\nlines(saison_sommer$Jahr, saison_sommer$Bern_Mitteltemperatur,\n    col = \"red\")\nlines(saison_herbst$Jahr, saison_herbst$Bern_Mitteltemperatur,\n    col = \"green\")\nlines(saison_winter$Jahr, saison_winter$Bern_Mitteltemperatur,\n    col = \"blue\")\n\n# Gestrichelte Horizontale Linie bei 0 hinzufügen\nabline(h = 0, lty = 2)\n\n# Saisonale Mittelwertlinien hinzufügen\nabline(h = mean(saison_fruehling$Bern_Mitteltemperatur),\n    col = \"black\",\n    lty = 3)\nabline(h = mean(saison_sommer$Bern_Mitteltemperatur),\n    col = \"red\",\n    lty = 3)\nabline(h = mean(saison_herbst$Bern_Mitteltemperatur),\n    col = \"green\",\n    lty = 3)\nabline(h = mean(saison_winter$Bern_Mitteltemperatur),\n    col = \"blue\",\n    lty = 3)\n\n# Legende hinzufügen\nlegend(\"topright\",\n    legend = c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\"),\n    col = c(\"black\", \"red\", \"green\", \"blue\"),\n    lty = 1,\n    xpd = TRUE)\n\n\n\n\n\n\n\n\nSchauen wir uns nun die verschiedenen Schritte im Detail an.\n\nCSV-Datei einlesen: Zuerst lesen wir die CSV-Datei meteodaten_saison.csv ein.\n\n\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv',\n    sep = ',',\n    header = TRUE)\n\nDer Parameter sep = ',' gibt an, dass die Werte in der CSV-Datei durch Kommas getrennt sind.\nDer Parameter header = TRUE gibt an, dass die erste Zeile der CSV-Datei die Spaltennamen enthält.\n\nSubsets der Daten erstellen: Da unser Data Frame meteodaten Daten aus verschiedenen Jahreszeiten enthält, erstellen wir Subsets für jede Jahreszeit. Damit können wir die Daten für jede Jahreszeit separat plotten.\n\n\n# Subsets der Daten erstellen\nsaison_fruehling &lt;- meteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\nsaison_herbst &lt;- meteodaten[meteodaten$Saison == \"Herbst(SON)\", ]\nsaison_winter &lt;- meteodaten[meteodaten$Saison == \"Winter(DJF)\", ]\n\nMit dem == Operator vergleichen wir die Werte auf Gleichheit.\n\nmeteodaten$Saison == \"Fruehling(MAM)\"\n\nWir überprüfen also Zeile für Zeile, ob der Wert in der Spalte Saison gleich dem String \"Fruehling(MAM)\" ist. Dies wird in einen boolschen Vektor umgewandelt, der TRUE für Zeilen enthält, die dem Kriterium entsprechen, und FALSE für Zeilen, die es nicht tun.\nBetrachten wir nun eine Klammer weiter aussen, um zu verstehen, was genau wir dem Subset zuweisen.\n\nmeteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\n\nHier wählen wir alle Zeilen aus dem Data Frame meteodaten aus, in denen die Spalte Saison den Wert \"Fruehling(MAM)\" hat. Da wir nach dem letzten Komma nichts weiter angeben, wählen wir alle Spalten aus.\nUnsere Saisonalen Data Frames enthalten also nicht nur die Temperatur-Mittelwerte aus Bern, sondern auch die Niederschlagswerte von Bern und dem Grossen St. Bernhard. Wir greifen im erstellten Plot nur auf die Temperaturwerte zu.\n\nPlot mit den Saisontemperaturen erstellen: Wir erstellen einen Plot mit den saisonalen Durchschnittstemperaturen in Bern.\n\n\n# Plot mit den Saisontemperaturen erstellen erstellen\nplot(saison_fruehling$Jahr, saison_fruehling$Bern_Mitteltemperatur,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Saisonale Durchschnittstemperaturen in Bern\",\n    xlim = c(1900, 2020),\n    ylim = c(-5, 35))\n\nDie plot() Funktion hat viele Parameter, die wir verwenden können, um den Plot anzupassen.\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nplot(x, y)\nErstellt einen Plot der Werte in x gegen die Werte in y. Wir plotten hier die Spalte Jahr aus dem Subset saison_fruehling gegen die Spalte Bern_Mitteltemperatur aus dem gleichen subset.\n\n\ntype\nGibt den Typ des Plots an. Hier verwenden wir \"l\", um eine Linie zu zeichnen.\n\n\nxlab\nBeschriftung der x-Achse.\n\n\nylab\nBeschriftung der y-Achse.\n\n\nmain\nTitel des Plots.\n\n\nxlim\nBereich der x-Achse. Hier von 1900 bis 2020.\n\n\nylim\nBereich der y-Achse. Hier von -5 bis 35.\n\n\n\n\nWeitere Linien für andere Jahreszeiten auf den selben Plot hinzufügen: Wir fügen Linien für die anderen Jahreszeiten hinzu.\n\nIn R können wir mit der lines() Funktion weitere Linien zu einem bestehenden Plot hinzufügen.\n\n# Weitere Linien für andere Jahreszeiten auf den selben Plot hinzufügen\nlines(saison_sommer$Jahr, saison_sommer$Bern_Mitteltemperatur,\n    col = \"red\")\nlines(saison_herbst$Jahr, saison_herbst$Bern_Mitteltemperatur,\n    col = \"green\")\nlines(saison_winter$Jahr, saison_winter$Bern_Mitteltemperatur,\n    col = \"blue\")\n\nHier müssen wir jeweils nicht mehr ganz so viele Parameter angeben, da wir bereits die Achsenbesschriftung etc. vorgenommen haben. Was wir noch angeben müssen, ist die Farbe der Linie mit dem col Parameter.\n\nGestrichelte Horizontale Linie bei 0 hinzufügen: Wir fügen eine gestrichelte Horizontale Linie bei 0 hinzu.\n\n\n# Gestrichelte Horizontale Linie bei 0 hinzufügen\nabline(h = 0, lty = 2)\n\nMit der abline() Funktion können wir Linien zu einem Plot hinzufügen. Mit dem h Parameter geben wir die y-Position der Linie an, und mit dem lty Parameter geben wir den Linientyp an. Hier verwenden wir lty = 2, um eine gestrichelte Linie zu zeichnen.\n\nSaisonale Mittelwertlinien hinzufügen: Wir fügen Mittelwertlinien für jede Jahreszeit hinzu.\n\n\n# Saisonale Mittelwertlinien hinzufügen\nabline(h = mean(saison_fruehling$Bern_Mitteltemperatur),\n    col = \"black\",\n    lty = 3)\nabline(h = mean(saison_sommer$Bern_Mitteltemperatur),\n    col = \"red\",\n    lty = 3)\nabline(h = mean(saison_herbst$Bern_Mitteltemperatur),\n    col = \"green\",\n    lty = 3)\nabline(h = mean(saison_winter$Bern_Mitteltemperatur),\n    col = \"blue\",\n    lty = 3)\n\nHier fügen wir gestrichelte Linien für die Mittelwerte der Temperatur für jede Jahreszeit hinzu. Wir verwenden die mean() Funktion, um direkt im Aufruf den Mittelwert zu berechnen.\n\nLegende hinzufügen: Wir fügen eine Legende für die verschiedenen Linien hinzu.\n\n\n# Legende hinzufügen\nlegend(\"topright\",\n    legend = c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\"),\n    col = c(\"black\", \"red\", \"green\", \"blue\"),\n    lty = 1,\n    xpd = TRUE)\n\nMit der legend() Funktion können wir eine Legende zu einem Plot hinzufügen. Wir geben die Position der Legende mit dem topright Parameter an. Mit dem legend Parameter geben wir die Beschriftungen für die Linien an. Mit dem col Parameter geben wir die Farben der Linien an. Mit dem lty Parameter geben wir den Linientyp an. Mit dem xpd Parameter geben wir an, ob die Legende ausserhalb des Plots sein soll.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#scatterplots-und-aggregate-funktion",
    "href": "plots_in_R.html#scatterplots-und-aggregate-funktion",
    "title": "3  Einfache Plots erstellen",
    "section": "4.2 Scatterplots und aggregate()-Funktion",
    "text": "4.2 Scatterplots und aggregate()-Funktion\nWenn wir von unseren nach Jahreszeiten sortierten Daten nun bspw. den Durchschnitt der Temperaturwerte pro Jahr berechnen wollen, können wir die aggregate() Funktion verwenden.\n\n# Durchschnittstemperatur pro Jahr berechnen\ndurchschnittstemperatur_pro_jahr &lt;- aggregate(Bern_Mitteltemperatur ~ Jahr,\n    data = meteodaten,\n    FUN = mean)\n\n# Plot erstellen\nplot(durchschnittstemperatur_pro_jahr$Jahr,\n    durchschnittstemperatur_pro_jahr$Bern_Mitteltemperatur,\n    type = \"p\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur pro Jahr in Bern\")\n\n# Lineares Modell (lineare Regression) erstellen\ntrend &lt;- lm(Bern_Mitteltemperatur ~ Jahr,\n    data = durchschnittstemperatur_pro_jahr)\n\n# Trendlinie hinzufügen\nabline(trend,\n    col = \"red\",\n    lwd = 2)  # Die Farbe und Dicke der Linie anpassen\n\n\n\n\n\n\n\n\nDie aggregate() Funktion nimmt vier Parameter:\n\nDie Spalte, nach der aggregiert werden soll (Bern_Mitteltemperatur).\nDie Spalte, nach der gruppiert werden soll (Jahr).\nDie Daten, auf die die Funktion angewendet werden soll (meteodaten).\nDie Funktion, die auf die aggregierten Werte angewendet werden soll (mean).\n\nDer ~-Operator wird in R verwendet, um die linke Seite von der rechten Seite zu trennen. In diesem Fall bedeutet dies, dass wir die Spalte Bern_Mitteltemperatur nach der Spalte Jahr aggregieren wollen.\nZusätzlich haben wir hier noch eine Trendlinie hinzugefügt. Dazu haben wir ein lineares Modell mit der lm() Funktion erstellt und die Trendlinie mit der abline() Funktion hinzugefügt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#boxplots-und-mehrere-plots-in-einem-diagramm",
    "href": "plots_in_R.html#boxplots-und-mehrere-plots-in-einem-diagramm",
    "title": "3  Einfache Plots erstellen",
    "section": "4.3 Boxplots und mehrere Plots in einem Diagramm",
    "text": "4.3 Boxplots und mehrere Plots in einem Diagramm\nWir wollen nun für die Temperaturen und Niederschlagswerte in Bern und auf dem Grossen St. Bernhard Boxplots erstellen und diese in einem Diagramm nebeneinander plotten. Zusätzlich wollen wir die Daten Zeitlich bis ins Jahr 1980 beschränken. Auch dieser Code enthält einige zusätzliche und neue Schritte, welche wir uns anschliessend genauer ansehen.\n\n# Definiere neue Kategorien-Namen und die gewünschte Reihenfolge\nneue_namen &lt;- c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\")\nalte_namen &lt;- c(\"Fruehling(MAM)\", \"Sommer(JJA)\", \"Herbst(SON)\", \"Winter(DJF)\")\n\n# Konvertiere 'Saison' in einen Faktor mit den neuen Namen und der gewünschten Reihenfolge\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = alte_namen,\n                            labels = neue_namen)\n\n# Mehrere Plots in einem Diagramm\npar(mfrow = c(2, 2), # 2 Zeilen und 2 Spalten\n    mar = c(4, 4, 2, 1), # verkleinert die Ränder\n    oma = c(0, 0, 4, 0), # fügt Platz für den Titel hinzu\n    cex = 0.8) # verkleinert die Schriftgrösse\n\n# Boxplots erstellen\nboxplot(Bern_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Bern\")\n\nboxplot(GrStBernhard_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Gr. St. Bernhard\")\n\nboxplot(Bern_Niederschlagssumme ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(0, 400),\n    ylab = \"Niederschlag in mm\",\n    main = \"Niederschlag Bern\")\n\nboxplot(GrStBernhard_Niederschlagssumme ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(0, 400),\n    ylab = \"Niederschlag in mm\",\n    main = \"Niederschlag Gr. St. Bernhard\")\n\n# Gesamte Überschrift für alle Plots hinzufügen\ntitle(\"Klimadaten in Bern und auf dem Grossen St. Bernhard\", outer = TRUE)\n\n\n\n\n\n\n\n\nSchauen wir uns die verschiedenen Schritte im Detail an:\n\nDefiniere neue Kategorien-Namen und die gewünschte Reihenfolge: Die Kategorien-Namen haben bisher die Form Fruehling(MAM), Sommer(JJA), Herbst(SON), Winter(DJF). Um die Lesbarkeit zu verbessern und etwas kürzere Namen zu verwenden, definieren wir neue Namen. In einem nächsten Schritt konvertieren wir die Spalte Saison in einen Faktor1 mit den neuen Namen und der gewünschten Reihenfolge.\n\n\nneue_namen &lt;- c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\")\nalte_namen &lt;- c(\"Fruehling(MAM)\",\n                \"Sommer(JJA)\",\n                \"Herbst(SON)\",\n                \"Winter(DJF)\")\n\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = alte_namen,\n                            labels = neue_namen)\n\nWir verwenden die factor() Funktion, um die Spalte Saison, die aktuell als Strings vorliegt, in einen Faktor zu konvertieren. Mit dem levels Parameter geben wir die Reihenfolge der vorhandenen Werte in den Daten an – hier die alten Namen, da diese in den Rohdaten stehen. Der labels Parameter definiert die neuen Namen, die im Plot oder bei Ausgaben angezeigt werden sollen.\nWichtig zu verstehen ist, dass die Umwandlung mit factor() nicht die zugrunde liegenden Daten ändert, sondern nur die Art und Weise, wie die Kategorien dargestellt werden. Die ursprünglichen Werte (also die alten Namen) bleiben im Data Frame erhalten2, aber R verwendet die neuen Labels, um diese Werte im Plot oder bei der Ausgabe anders zu präsentieren.\n\nMehrere Plots in einem Diagramm: Mit der par() Funktion können wir das Layout und die Platzierung der Plots anpassen.\n\n\nMit dem mfrow Parameter geben wir an, wie viele Zeilen und Spalten von Plots wir haben wollen. Hier haben wir 2 Zeilen und 2 Spalten.\nMit dem mar Parameter können wir die Ränder des Plots anpassen.\nMit dem oma Parameter können wir Platz für den Titel des gesamten Diagramms hinzufügen.\nMit dem cex Parameter können wir die Schriftgrösse anpassen.\n\n\npar(mfrow = c(2, 2), # 2 Zeilen und 2 Spalten\n    mar = c(4, 4, 2, 1), # verkleinert die Ränder\n    oma = c(0, 0, 4, 0), # fügt Platz für den Titel hinzu\n    cex = 0.8) # verkleinert die Schriftgrösse\n\n\nBoxplots erstellen: Wir erstellen Boxplots für die Durchschnittstemperaturen und Niederschlagssummen in Bern und auf dem Grossen St. Bernhard.\n\nZusätzlich beschränken wir die Daten auf die Jahre bis 1980.\n\nboxplot(Bern_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Bern\")\n\nWir beachten auch hier wieder die Verwendung des ~-Operators, um die linke Seite von der rechten Seite zu trennen. In diesem Fall bedeutet dies, dass wir die Spalte Bern_Mitteltemperatur nach der Spalte Saison gruppieren wollen.\nWir verwenden die ylim Parameter, um die y-Achse auf einen bestimmten Bereich zu beschränken. Dies ist nützlich, um die Plots besser vergleichen zu können.\nDie Selelektion der Daten erflogt im data Parameter. Hier wählen wir nur die Daten bis ins Jahr 1980 aus.\n\nGesamte Überschrift für alle Plots hinzufügen: Wir fügen eine Überschrift für alle Plots hinzu.\n\n\ntitle(\"Klimadaten in Bern und auf dem Grossen St. Bernhard\", outer = TRUE)\n\nDer outer Parameter gibt an, dass die Überschrift über allen Plots platziert werden soll.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#grafiken-speichern",
    "href": "plots_in_R.html#grafiken-speichern",
    "title": "3  Einfache Plots erstellen",
    "section": "4.4 Grafiken speichern",
    "text": "4.4 Grafiken speichern\nGrafiken können entweder in RStudio unter dem Reiter “Export” … “Save Plot as PDF” oder “…Image” gespeichert werden.\nAlternativ können mit den Funktionen pdf(), jpeg() und png() Grafiken direkt in R gespeichert werden.\n\n# PDF-Datei erstellen\npdf(file = \"boxplots.pdf\",\n    width = 9,\n    height = 4.5) # Grösse des PDFs in Inch\n\n# Boxplot aus der vorherigen Sektion erstellen\nboxplot(Bern_Mitteltemperatur ~ Saison,\n        data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n        ylim = c(-10, 20),\n        ylab = \"Durchschnittstemperatur in °C\",\n        main = \"Durchschnittstemperatur Bern\")\n\n# PDF-Datei schliessen\ndev.off()\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden. Wichtig ist die entsprechende Dateieindung (.pdf, .jpeg oder .png) anzugeben.\n\n\nwidth\nBreite des Plots in Inch.\n\n\nheight\nHöhe des Plots in Inch.\n\n\ndev.off()\nIst kein eigentlicher Parameter, aber ist am Ende jeder der Funktionen benötigt, um den Export zu beenden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#übungen-3",
    "href": "plots_in_R.html#übungen-3",
    "title": "3  Einfache Plots erstellen",
    "section": "Übungen 3",
    "text": "Übungen 3\n\n3.1 Klimadiagramm\n\nLadet den Datensatz meteodaten_tag.csv nach dem Excel Export in R (ACHTUNG: NA-Werte sind sowohl mit’-’als auch mit’NA’)kodiert, deshalb: na.strings= c('-','NA'))\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# CSV-Datei einlesen\nmeteodaten_tag &lt;- read.csv('Data/meteodaten_tag.csv',\n    sep = ',',\n    header = TRUE,\n    na.strings = c('-', 'NA'))\n\n\n\n\n\nMit str() ansehen, ob Daten korrekt (z.B.als numerisch) gelesen wurden.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nstr(meteodaten_tag)\n\n'data.frame':   4627 obs. of  7 variables:\n $ Jahr                : int  2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 ...\n $ Monat               : int  1 1 1 1 1 1 1 1 1 1 ...\n $ Tag                 : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Wochentag           : chr  \"Sa\" \"So\" \"Mo\" \"Di\" ...\n $ Temperatur.C.       : num  3.6 4.8 4.6 6.2 8.1 6.9 3.4 2.4 5.5 5.1 ...\n $ Niederschlag.mm.Tag.: num  0 0 0 0 0.2 0 0 0 0.5 1.8 ...\n $ Bewoelkung.Achtel.  : int  3 7 3 3 3 3 6 6 6 7 ...\n\n\n\n\n\n\nErstellt ein Histogramm (hist()) mit den Tagestemperaturen mit feinen Abständen (breaks=40).\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nhist(meteodaten_tag$Temperatur.C.,\n     breaks = 40,\n     xlab = \"Temperatur in °C\",\n     ylab = \"Anzahl Tage\",\n     main = \"Histogramm der Tagestemperaturen in Bern\")\n\n\n\n\n\n\n\n\n\n\n\n\nWie sieht die Verteilung nach Augenmass aus?\nBerechnet die Monatsmittelwerte der Temperatur und der Bewölkung über alle Jahre (also Mittel über alle Jan, alle Feb,… wie in Klimadiagrammen). Achtung: Fehlwerte vorhanden!\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nmonatsmittel &lt;-\n    aggregate(cbind(Temperatur.C., Bewoelkung.Achtel.) ~ Monat,\n        data = meteodaten_tag,\n        FUN = mean,\n        na.rm = TRUE)\n\nHinweis zur Funktion cbind(): cbind() fügt die Spalten Bern_Temperatur und Bern_Bewoelkung zusammen, um sie dann nach Monat zu gruppieren. Alternativ könnten wir die beiden Mittelwerte auch seperat berechnen und anschliessend mit einem merge() zusammenfügen.\n\ntemp_mittel &lt;- aggregate(Temperatur.C. ~ Monat,\n    data = meteodaten_tag,\n    FUN = mean,\n    na.rm = TRUE)\nbewoelkung_mittel &lt;- aggregate(Bewoelkung.Achtel. ~ Monat,\n    data = meteodaten_tag,\n    FUN = mean,\n    na.rm = TRUE)\n\nmonatsmittel &lt;- merge(temp_mittel, bewoelkung_mittel,\n    by = \"Monat\")\n\n\n\n\n\nErstellt in eine Abbildung mit zwei Barplots der Ergebnisse übereinander(par(mfrow=c(2,1))). Was erwartet ihr?\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# Mehrere Plots in einem Diagramm\npar(mfrow = c(2, 1))\n\n# Barplot für die Monatsmittel der Temperatur\nbarplot(temp_mittel$Temperatur.C.,\n    names.arg = temp_mittel$Monat,\n    xlab = \"Monat\",\n    ylab = \"Temp. in °C\",\n    main = \"Monatsmittel der Temperatur in Bern\")\n\n# Barplot für die Monatsmittel der Bewölkung\nbarplot(bewoelkung_mittel$Bewoelkung.Achtel.,\n    names.arg = bewoelkung_mittel$Monat,\n    xlab = \"Monat\",\n    ylab = \"Bewölkung in Achteln\",\n    main = \"Monatsmittel der Bewölkung in Bern\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 Boxplots\n\nWählt den Zeitraum 200-2001 in den täglichen Daten.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# Data Frame filtern und in einem neuen Objekt speichern\nmeteodaten_tag_2000_2001 &lt;- meteodaten_tag[meteodaten_tag$Jahr &gt;= 2000 & meteodaten_tag$Jahr &lt;= 2001, ]\n\n\n\n\n\nStellt die Temperaturen dieses Zeitrauemes als Funktion der Bewölkung in einem boxpolt()dar (je ein Boxplot pro Bewölkungsklasse). Beschriftet die Achsen und vergebt einen Titel\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nboxplot(Temperatur.C. ~ Bewoelkung.Achtel.,\n    data = meteodaten_tag_2000_2001,\n    ylab = \"Temperatur in °C\",\n    xlab = \"Bewölkung in Achteln\",\n    main = \"Temperaturen in Bern 2000-2001 nach Bewölkung\")\n\n\n\n\n\n\n\n\n\n\n\n\nUnter welchen Bewölkungsbedingungen ist die Spannweite und Varianz der Temperatur am grössten?\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# Berechnung der Spannweite und Varianz der Temperatur für jede Bewölkungsklasse\nspannweite &lt;- aggregate(Temperatur.C. ~ Bewoelkung.Achtel.,\n    data = meteodaten_tag_2000_2001,\n    FUN = function(x) diff(range(x)))\n\nvarianz &lt;- aggregate(Temperatur.C. ~ Bewoelkung.Achtel.,\n    data = meteodaten_tag_2000_2001,\n    FUN = var)\n\n# Umbenennen der Spalten, um Verwechslungen zu vermeiden\nnames(spannweite)[2] &lt;- \"Spannweite\"\nnames(varianz)[2] &lt;- \"Varianz\"\n\n# Zusammenführen der Ergebnisse\nergebnisse &lt;- merge(spannweite, varianz, by = \"Bewoelkung.Achtel.\")\n\n# Ausgabe der Ergebnisse\nergebnisse\n\n  Bewoelkung.Achtel. Spannweite  Varianz\n1                  0       24.3 52.71585\n2                  1       29.0 60.76026\n3                  2       31.0 44.37131\n4                  3       33.5 54.83717\n5                  4       28.3 36.53915\n6                  5       24.5 34.10751\n7                  6       24.2 23.78013\n8                  7       21.7 29.81474\n9                  8       15.6 14.02061\n\n\n\n\n\n\nFindet heraus welcher Monat im Mittel der bewölkungsärmste und der -reichste ist (Im Mittel über die beiden Jahre). Wie viel Bewälkung gibt es im Mittel in diesen Monaten (in Achteln)?\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# Berechnung der Monatsmittel der Bewölkung\nbewoelkung_mittel &lt;- aggregate(Bewoelkung.Achtel. ~ Monat,\n    data = meteodaten_tag_2000_2001,\n    FUN = mean,\n    na.rm = TRUE)\n\n# Bewölkungsärmster Monat\nbewoelkung_min &lt;- bewoelkung_mittel[which.min(bewoelkung_mittel$Bewoelkung.Achtel.), ]\nbewoelkung_min\n\n  Monat Bewoelkung.Achtel.\n8     8           1.854839\n\n# Bewölkungsreichster Monat\nbewoelkung_max &lt;- bewoelkung_mittel[which.max(bewoelkung_mittel$Bewoelkung.Achtel.), ]\nbewoelkung_max\n\n   Monat Bewoelkung.Achtel.\n12    12           5.016129",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#footnotes",
    "href": "plots_in_R.html#footnotes",
    "title": "3  Einfache Plots erstellen",
    "section": "",
    "text": "Ein Faktor ist ein Datentyp in R, der kategorische Daten repräsentiert. Faktoren werden verwendet, um Daten zu kategorisieren und zu ordnen.↩︎\nWenn eine Spalte mit factor() bearbeitet wird, wird sie intern in diskrete Kategorien umgewandelt, jedoch ohne die ursprünglichen Daten zu überschreiben. Der levels Parameter bezieht sich auf die originalen Datenwerte, um sicherzustellen, dass R die Daten korrekt interpretiert. Die labels hingegen ändern nur, wie diese Daten für den Benutzer angezeigt werden. Dadurch bleibt der Inhalt des Data Frames unverändert, aber die Darstellung der Werte wird angepasst. Das ist nützlich, wenn man die Rohdaten beibehalten will, jedoch für Visualisierungen oder Präsentationen eine klarere oder kürzere Bezeichnung verwenden möchte.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html",
    "href": "packages_and_libraries.html",
    "title": "4  Packages und Libraries",
    "section": "",
    "text": "5 Packages und Libraries\nIn R gibt es ähnlich wie in Python und anderen Programmiersprachen die Möglichkeit, zusätzliche Funktionalitäten durch das Einbinden von Packages und Libraries zu nutzen. In R werden diese durch den Befehl library() eingebunden.\nDie Pakete müssen einmalig installiert werden und können dann immer am Anfang eines Skripts oder Notebooks geladen werden.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#pakete-installieren",
    "href": "packages_and_libraries.html#pakete-installieren",
    "title": "4  Packages und Libraries",
    "section": "5.1 Pakete installieren",
    "text": "5.1 Pakete installieren\nPakete können mit der Funktion install.packages() installiert werden. Zum Beispiel:\n\ninstall.packages(\"ggplot2\")\n\nUm Skripte und Notebooks portabel zu halten, ist es sinnvoll, die Installation von fehlenden Paketen am Anfang des Skripts oder Notebooks zu platzieren.\n\nif (!require(\"ggplot2\")) {\n  install.packages(\"ggplot2\")\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#pakete-laden",
    "href": "packages_and_libraries.html#pakete-laden",
    "title": "4  Packages und Libraries",
    "section": "5.2 Pakete laden",
    "text": "5.2 Pakete laden\nPakete können mit der Funktion library() geladen werden. Zum Beispiel:\n\nlibrary(ggplot2)\n\nDie meisten Pakete haben eine Vielzahl von Funktionen, die genutzt werden können. Es ist ratsam, die Dokumentation des Pakets zu lesen, um die verfügbaren Funktionen und deren Anwendung zu verstehen. Die Dokumentation eines Pakets kann mit dem Befehl ? aufgerufen werden. Zum Beispiel:\n\n?ggplot2",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#häufig-genutzte-pakete",
    "href": "packages_and_libraries.html#häufig-genutzte-pakete",
    "title": "4  Packages und Libraries",
    "section": "5.3 Häufig genutzte Pakete",
    "text": "5.3 Häufig genutzte Pakete\nEinige der am häufigsten genutzten Pakete in R sind:\n\nggplot2: Ein Paket zur Erstellung von ansprechenden und aussagekräftigen Grafiken.\ndplyr: Ein Paket zur Datenmanipulation und -aggregation.\ntidyr: Ein Paket zur Datenbereinigung und -umformung.\nreadr: Ein Paket zur Einlesung von Daten aus verschiedenen Dateiformaten.\nstringr: Ein Paket zur Arbeit mit Zeichenketten.\nlubridate: Ein Paket zur Arbeit mit Datum und Uhrzeit.\ncaret: Ein Paket zur Erstellung von Modellen und zur Modellauswertung.\ntidyverse: Ein Paket, das eine Sammlung von Paketen für die Datenanalyse in R bereitstellt.\n\nEs gibt viele weitere Pakete, die für spezifische Anwendungen und Analysen entwickelt wurden. Es ist ratsam, die Dokumentation der Pakete zu lesen, um die verfügbaren Funktionen und deren Anwendung zu verstehen.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#beispiel-einbinden-des-ggplot2-pakets",
    "href": "packages_and_libraries.html#beispiel-einbinden-des-ggplot2-pakets",
    "title": "4  Packages und Libraries",
    "section": "5.4 Beispiel: Einbinden des ggplot2 Pakets",
    "text": "5.4 Beispiel: Einbinden des ggplot2 Pakets\nAn einem einfachen Beispiel sehen wir, wie mit Hilfe der Pakete ggplot2 und plotly ein interaktives Diagramm erstellt werden kann.\n\n# Bibliotheken laden\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Daten für den Plot vorbereiten\n# Konvertiere die Spalte Saison in einen einfacheren Faktor für die Darstellung\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = c(\"Fruehling(MAM)\",\n                                       \"Sommer(JJA)\",\n                                       \"Herbst(SON)\",\n                                       \"Winter(DJF)\"),\n                            labels = c(\"Frühling\",\n                                       \"Sommer\",\n                                       \"Herbst\",\n                                       \"Winter\"))\n\n# Plot mit ggplot2 erstellen\ngg &lt;- ggplot(meteodaten, aes(x = Jahr,\n        y = Bern_Mitteltemperatur,\n        color = Saison)) +\n    geom_line(linewidth = 1.2) +  # Linienbreite anpassen\n    geom_hline(yintercept = 0,\n        linetype = \"dashed\") +  # Horizontale Linie bei 0\n    labs(title = \"Saisonale Durchschnittstemperaturen in Bern\",\n        x = \"Jahr\",\n        y = \"Durchschnittstemperatur in °C\") +\n    theme_minimal() +  # Minimalistisches Theme für einen klaren Look\n    scale_color_manual(values = c(\"Frühling\" = \"green\",\n                                  \"Sommer\" = \"red\",\n                                  \"Herbst\" = \"orange\",\n                                  \"Winter\" = \"blue\")) +  # Farben anpassen\n    theme(plot.title = element_text(hjust = 0.5,\n        size = 16))  # Zentriere Titel und passe die Schriftgröße an\n\n# Plot interaktiv machen mit plotly\ngg_interaktiv &lt;- ggplotly(gg)\n\n# Interaktiver Plot anzeigen\ngg_interaktiv\n\n\n\nInteraktives Diagramm der saisonalen Durchschnittstemperaturen in Bern",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#übungen",
    "href": "packages_and_libraries.html#übungen",
    "title": "4  Packages und Libraries",
    "section": "Übungen",
    "text": "Übungen\n\n3.4 R als GIS Ersatz\n\nInstalliert das Paket maps und ladet es in R (z.B. library(maps)) Findet die x,y-Koordinaten von Bern und dem Gr. S. Bernhard heraus.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nlibrary(maps)\n\n# Koordinaten für Bern und Grosser St. Bernhard\nbern_coords &lt;- c(7.4474, 46.9481)\ngross_bernhard_coords &lt;- c(7.1761, 45.8689)\n\n\n\n\n\nVersucht eine Europakarte herzustellen und Bern und Gr. Bernhard als Punkte auf die Karte zu plotten und die Punkte mit Stationsnamen zu versehen\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# Erstelle eine Europakarte\nmap(\"world\",\n    xlim = c(-10, 20),\n    ylim = c(35, 55),\n    fill = TRUE,\n    col = \"lightgray\")\n\n\n# Punkte auf der Karte plotten\npoints(bern_coords[1],\n       bern_coords[2],\n       col = \"red\",\n       pch = 19,\n       cex = 1.5)\npoints(gross_bernhard_coords[1],\n       gross_bernhard_coords[2],\n       col = \"blue\",\n       pch = 19,\n       cex = 1.5)\n\n# Text hinzufügen\ntext(bern_coords[1],\n     bern_coords[2],\n     labels = \"Bern\",\n     pos = 3,\n     cex = 0.8,\n     col = \"red\")\ntext(gross_bernhard_coords[1],\n     gross_bernhard_coords[2],\n     labels = \"Gr. St. Bernhard\",\n     pos = 3,\n     cex = 0.8,\n     col = \"blue\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html",
    "href": "loops_and_functions.html",
    "title": "5  Schlaufen und Funktionen",
    "section": "",
    "text": "6 Schlaufen und Funktionen",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#if-und-else",
    "href": "loops_and_functions.html#if-und-else",
    "title": "5  Schlaufen und Funktionen",
    "section": "6.1 if() und else()",
    "text": "6.1 if() und else()\nMit if() und else() können Bedingungen in R überprüft und entsprechende Aktionen ausgeführt werden. Die Syntax ist wie folgt:\n\nif (Bedingung) {\n  # Aktion, wenn die Bedingung TRUE ist\n} else {\n  # Aktion, wenn die Bedingung FALSE ist\n}\n\nZum Beispiel:\n\nx &lt;- 10\nif (x &gt; 5) {\n  print(paste(x, \"ist grösser als 5\"))\n} else {\n  print(\"x ist kleiner oder gleich 5\")\n}\n\n[1] \"10 ist grösser als 5\"\n\n\nHier verwenden wir zusätzlich die Funktion paste(), um Text und Variablen zu kombinieren. Dies ist ohne nicht direkt möglich.\n\n6.1.1 ifelse() als Vektoroperation\nifelse() ist eine Funktion, die eine Bedingung auf einen Vektor anwendet und basierend auf der Bedingung Werte zurückgibt. Die Syntax ist wie folgt:\n\nifelse(Bedingung, Wert_wenn_TRUE, Wert_wenn_FALSE)\n\nZum Beispiel:\n\nvectorA &lt;- c(1, 2, 3, 4, 5)\nifelse(vectorA == 3, \"Drei\", \"Nicht Drei\")\n\n[1] \"Nicht Drei\" \"Nicht Drei\" \"Drei\"       \"Nicht Drei\" \"Nicht Drei\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#schleifen",
    "href": "loops_and_functions.html#schleifen",
    "title": "5  Schlaufen und Funktionen",
    "section": "6.2 Schleifen",
    "text": "6.2 Schleifen\nSchleifen sind nützlich, um eine bestimmte Aktion mehrmals auszuführen. In R gibt es verschiedene Arten von Schleifen, darunter for, while und repeat.\n\n6.2.1 for Schleife\nDie for Schleife wird verwendet, um eine Aktion für jedes Element in einer Sequenz auszuführen. Die Syntax ist wie folgt:\n\nfor (Element in Sequenz) {\n  # Aktion, die für jedes Element ausgeführt wird\n}\n\nZum Beispiel:\n\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nSchleifen mit Laufindex\nLaufindexe können in R auch ausserhalb der Schleife definiert werden. Zum Beispiel:\n\noriginal_vector &lt;- c(1, 2, 3, 4, 5)\nresult_vector &lt;- vector() # Leerer Vektor für das Ergebnis\n\n# Laufindex definieren\nj &lt;- 1\n\nfor (i in original_vector) {\n  result_vector[j] &lt;- i * 2\n  j &lt;- j + 1\n}\n\nresult_vector\n\n[1]  2  4  6  8 10\n\n\nBemerkung: aus Python kennen wir j++ oder j += 1 um den Laufindex zu erhöhen. In R gibt es keinen solchen Shortcut.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#eigene-funktionen",
    "href": "loops_and_functions.html#eigene-funktionen",
    "title": "5  Schlaufen und Funktionen",
    "section": "6.3 Eigene Funktionen",
    "text": "6.3 Eigene Funktionen\nFunktionen sind nützlich, um wiederkehrende Aktionen zu kapseln und zu abstrahieren. In R können eigene Funktionen mit dem function Schlüsselwort definiert werden. Die Syntax ist wie folgt:\n\nfunktion_name &lt;- function(Parameter1, Parameter2, ...) {\n  # Aktionen, die die Funktion ausführt\n  return(Ergebnis)\n}\n\nZum Beispiel:\nWir schreiben eine Funktion, die die Summe der Quadrate von zwei Zahlen berechnet.\n\nsumme_quadrate &lt;- function(x, y) {\n  summe &lt;- x^2 + y^2\n  return(summe)\n}\n\nDie Funktion kann dann wie folgt aufgerufen werden:\n\nsumme_quadrate(3, 4)\n\n[1] 25",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "statistische-datenanalyse.html",
    "href": "statistische-datenanalyse.html",
    "title": "6  Statistische Datenanalyse",
    "section": "",
    "text": "6.1 Deskriptive Statistik",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statistische Datenanalyse</span>"
    ]
  },
  {
    "objectID": "statistische-datenanalyse.html#deskriptive-statistik",
    "href": "statistische-datenanalyse.html#deskriptive-statistik",
    "title": "6  Statistische Datenanalyse",
    "section": "",
    "text": "6.1.1 Grundgesamtheit vs. Stichprobe\n\n6.1.1.1 Grundgesamtheit \\(\\mu\\)\nDie Grundgesamtheit ist die Gesamtheit aller möglichen Werte einer Variablen. Zum Beispiel kann die Grundgesamtheit die Gesamtheit aller Menschen in einem Land, die Gesamtheit aller Autos einer bestimmten Marke oder die Gesamtheit aller Messungen eines Experiments sein.\n\n\n6.1.1.2 Stichprobe \\(\\bar{x}\\)\nEine Stichprobe ist eine Teilmenge der Grundgesamtheit. Die Stichprobe wird verwendet, um Rückschlüsse auf die Grundgesamtheit zu ziehen. Die Stichprobe sollte repräsentativ für die Grundgesamtheit sein, um gültige Schlussfolgerungen ziehen zu können.\n\n\n\n6.1.2 Skalen\n\n6.1.2.1 Kategoriale Variablen\n\nNominalskala\nNominalskalen sind die einfachste Form der Skala und werden verwendet, um Kategorien zu unterscheiden. Die Kategorien haben keine natürliche Reihenfolge oder Rangfolge. Beispiele für Nominalskalen sind Geschlecht, Augenfarbe oder Nationalität.\n\n\nOrdinalskala\nOrdinalskalen werden verwendet, um Kategorien zu unterscheiden, die eine natürliche Reihenfolge oder Rangfolge haben. Die Abstände zwischen den Kategorien sind jedoch nicht gleich. Beispiele für Ordinalskalen sind Schulnoten, sozioökonomischer Status oder Kundenzufriedenheit.\n\n\n\n6.1.2.2 Metrische Variablen\n\nIntervallskala\nIntervallskalen werden verwendet, um kontinuierliche Variablen zu messen, bei denen die Abstände zwischen den Werten gleich sind, aber kein absoluter Nullpunkt vorhanden ist. Beispiele für Intervallskalen sind Temperatur in Celsius oder IQ.\n\n\nVerhältnisskala\nVerhältnisskalen werden verwendet, um kontinuierliche Variablen zu messen, bei denen die Abstände zwischen den Werten gleich sind und ein absoluter Nullpunkt vorhanden ist. Beispiele für Verhältnisskalen sind Gewicht, Grösse oder Einkommen.\n\n\n\n\n6.1.3 Lageparameter / Masse der Zentraltendenz\n\n6.1.3.1 Modus\nDer Modus ist der Wert, der am häufigsten in einer Variablen vorkommt. Es ist möglich, dass eine Variable mehrere Modi hat (unimodal, bimodal, multimodal).\n\n\n6.1.3.2 Median\nDer Median ist der Wert, der die Daten in zwei gleich grosse Teile teilt. Der Median ist robust gegenüber Ausreissern und wird verwendet, wenn die Daten nicht normalverteilt sind.\n\\[\n\\text{Median} = \\begin{cases}\n      x_{\\frac{n+1}{2}} & \\text{für ungerade Anzahl von Werten} \\\\\n      \\frac{1}{2} (x_{\\frac{n}{2}} + x_{\\frac{n}{2}+1}) & \\text{für gerade Anzahl von Werten}\n   \\end{cases}\n\\]\n\n\n6.1.3.3 Arithmetischer Mittelwert \\(\\bar{x}\\)\nDas arithmetische Mittel ist der Durchschnittswert einer Variablen und wird berechnet, indem alle Werte addiert und durch die Anzahl der Werte geteilt werden. Die Formel lautet:\n\\[\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i = \\frac{x_1 + x_2 + \\ldots + x_n}{n}\n\\]\nWo \\(\\bar{x}\\) das arithmetische Mittel ist, \\(n\\) die Anzahl der Werte und \\(x_i\\) die einzelnen Werte.\n\n\n\n6.1.4 Streuungsparameter\n\n6.1.4.1 Quantile \\(q\\%\\)\nDas \\(q\\%\\)-Quantil ist der Wert, unter dem \\(q\\%\\) der Daten liegen.\n\nSpezielle Quantile\n\nMedian ist \\(Q_{0.5}\\)\nQuartile: \\(Q_{0.25}\\), \\(Q_{0.5}\\), \\(Q_{0.75}\\)\nWhisker im Boxplot sind uneinheitlich definiert.\n\n\n\n\n6.1.4.2 Spannweite\nDie Spannweite ist die Differenz zwischen dem grössten und dem kleinsten Wert einer Variablen. Die Spannweite ist anfällig gegenüber Ausreissern.\n\\[\n\\text{Spannweite} = x_{\\text{max}} - x_{\\text{min}}\n\\]\n\n\n6.1.4.3 Varianz \\(s^2\\)\nMittle quadratische Abweichungen vom Mittelwert.\n\\[\ns^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\n\\]\n\n\n6.1.4.4 Standardabweichung \\(s\\)\nDie Standardabweichung ist die Quadratwurzel der Varianz und gibt an, wie stark die Werte einer Variablen um den Mittelwert streuen.\n\\[\ns = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2}\n\\]\n\n\n6.1.4.5 Schiefe\nEinfaches Mass für die Asymmetrie der Verteilung.\n\\[\n\\text{Schiefe} = \\frac{\\text{arithm. Mittel} - \\text{Median}}{\\text{Standardabweichung}}\n\\]\n\n\n\nSchiefe der Verteilung\n\n\n\n\n\n6.1.5 Kreuztabelle / Kontingenztafel\n\nFür nominale Daten\nOrdinale und metrische Daten können in nominale Daten transformiert werden (z.b. Grenzüberschreitung ja/nein)\n\nBeispiel:\nEs werden 2000 Personen darüber befragt, ob sie Produkt A oder B bevorzugen. Das Ergebnis wird nach Geschlecht des Befragten ausgewertet.\n\n\n\nProdukt / Geschlecht\nMännlich\nWeiblich\nSumme\n\n\n\n\nA\n660\n440\n1100\n\n\nB\n340\n560\n900\n\n\nSumme\n1000\n1000\n2000\n\n\n\n\n6.1.5.1 Freiheitsgrade\n\nAnzahl Beobachtungen abzüglich Anzahl geschätzter Parameter.\nBeispiel: Standardabweichung aus Stichprobe mit \\(n\\) Beobachtungen\n\n\\[\ns = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2}\n\\]\n\nDer Mittelwert wurde bereits aus den Beobachtungen geschätzt. Wenn man den Mittwelwert und alle Beobachtungen ausser der letzten kennt (\\(n-1\\)) dann kann man diese berechnen, es besteht also keine “Freiheit” mehr.\n\n\n# Grundgesamtheit erstellen\npopulation &lt;- rnorm(100000, mean = 0, sd = 10)\n\n# Standardabweichung der Grundgesamtheit\npopulation_sd &lt;- sqrt(sum((population - mean(population))^2) / 100000)\nprint(population_sd)\n\n[1] 10.00257\n\n# Eine Stichprobe aus der Grundgesamtheit ziehen\nsample_data &lt;- sample(population, 30)\n\n# Standardabweichung der Stichprobe (mit n und n-1)\nsample_sd_n &lt;- sqrt(sum((sample_data - mean(sample_data))^2) / 30)\nsample_sd_n_minus_1 &lt;- sqrt(sum((sample_data - mean(sample_data))^2) / (30 - 1))\n\nprint(sample_sd_n)\n\n[1] 8.812552\n\nprint(sample_sd_n_minus_1)\n\n[1] 8.963205\n\n# Viele Stichproben ziehen und die Standardabweichung berechnen\nsample_sd_n_list &lt;- vector(\"numeric\", 1000)\nsample_sd_n_minus_1_list &lt;- vector(\"numeric\", 1000)\n\nfor (i in 1:1000) {\n  sample_data &lt;- sample(population, 30)\n  sample_sd_n_list[i] &lt;- sqrt(sum((sample_data - mean(sample_data))^2) / 30)\n  sample_sd_n_minus_1_list[i] &lt;- sqrt(sum((sample_data - mean(sample_data))^2) / (30 - 1))\n}\n\n# Mittelwerte der berechneten Standardabweichungen\nmean_sd_n &lt;- mean(sample_sd_n_list)\nmean_sd_n_minus_1 &lt;- mean(sample_sd_n_minus_1_list)\n\nprint(mean_sd_n)\n\n[1] 9.754878\n\nprint(mean_sd_n_minus_1)\n\n[1] 9.92164",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statistische Datenanalyse</span>"
    ]
  },
  {
    "objectID": "statistische-datenanalyse.html#schliessende-statistik",
    "href": "statistische-datenanalyse.html#schliessende-statistik",
    "title": "6  Statistische Datenanalyse",
    "section": "6.2 Schliessende Statistik",
    "text": "6.2 Schliessende Statistik",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statistische Datenanalyse</span>"
    ]
  },
  {
    "objectID": "excercises/ex04.html",
    "href": "excercises/ex04.html",
    "title": "Appendix A — Übung 4: Deskriptive Statistik und Visualisierung",
    "section": "",
    "text": "A.1 Histogramm und Kennzahlen\nIhr möchtet die mittlere Jahresniederschlagssumme und die mittlere Jahrestemperatur sowie deren Varianz von Jahr zu Jahr bestimmen, um die Klimabedingungen in Bern zu beschreiben.\nUm die richtigen Kennzahlen (Mittelwert, Median, Modus, etc.) zu wählen, müssen wir die Verteilung der Daten kennen. Erstellt ein Histogramm der Jahresmitteltemperaturen und -niederschlag:\n# Jahresdaten erstellen\n# Berechne Jahresmittelwerte und -summen\njahresmitteltemp_bern &lt;- aggregate(meteodaten$Bern_Mitteltemperatur ~ meteodaten$Jahr,\n                                   FUN = mean,\n                                   na.rm = TRUE)\njahresmitteltemp_grstbernhard &lt;- aggregate(meteodaten$GrStBernhard_Mitteltemperatur ~ meteodaten$Jahr,\n                                           FUN = mean,\n                                           na.rm = TRUE)\njahresniederschlag_bern &lt;- aggregate(meteodaten$Bern_Niederschlagssumme ~ meteodaten$Jahr,\n                                     FUN = sum,\n                                     na.rm = TRUE)\njahresniederschlag_grstbernhard &lt;- aggregate(meteodaten$GrStBernhard_Niederschlagssumme ~ meteodaten$Jahr,\n                                             FUN = sum,\n                                             na.rm = TRUE)\n\n# Kombiniere die Ergebnisse in eine neue Tabelle\njahresdaten &lt;- data.frame(\n  Jahr = jahresmitteltemp_bern$`meteodaten$Jahr`,\n  Bern_Mitteltemperatur = jahresmitteltemp_bern$`meteodaten$Bern_Mitteltemperatur`,\n  GrStBernhard_Mitteltemperatur = jahresmitteltemp_grstbernhard$`meteodaten$GrStBernhard_Mitteltemperatur`,\n  Bern_Niederschlagssumme = jahresniederschlag_bern$`meteodaten$Bern_Niederschlagssumme`,\n  GrStBernhard_Niederschlagssumme = jahresniederschlag_grstbernhard$`meteodaten$GrStBernhard_Niederschlagssumme`\n)\n\n\nhist(jahresdaten$Bern_Mitteltemperatur,\n     main = 'Histogramm der Mitteltemperatur in Bern',\n     xlab = 'Mitteltemperatur (°C)',\n     ylab = 'Anzahl der Jahre',\n     xlim = c(6, 12),\n     ylim = c(0, 15),\n     breaks = 30)\n\n\n\n\n\n\n\nhist(jahresdaten$Bern_Niederschlagssumme,\n     main = 'Histogramm der Niederschlagssumme in Bern',\n     xlab = 'Niederschlagssumme (mm)',\n     ylab = 'Anzahl der Jahre',\n     xlim = c(500, 1500),\n     ylim = c(0, 10),\n     breaks = 30)\nBeide Verteilungen sind ungefähr symmetrisch, da die Daten in der Mitte des Bereichs konzentriert sind und die Verteilung nach links und rechts ungefähr gleich ist. Dies ist aber mit so “wenigen” Daten nicht wirklich aussagekräftig. Das macht aber bei der Art der Daten Sinn, da die Temperatur und Niederschlagssumme in der Regel normalverteilt sind.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Übung 4: Deskriptive Statistik und Visualisierung</span>"
    ]
  },
  {
    "objectID": "excercises/ex04.html#histogramm-und-kennzahlen",
    "href": "excercises/ex04.html#histogramm-und-kennzahlen",
    "title": "Appendix A — Übung 4: Deskriptive Statistik und Visualisierung",
    "section": "",
    "text": "A.1.1 Kennzahlen\nWelche Kennzahlen zur Beschreibung des Mittels und der Streuung kommen aufgrund den Verteilung und Skala der Daten in Frage?\nDa die Daten normalverteilt sind, können wir den Mittelwert und die Standardabweichung verwenden, um die zentrale Tendenz und die Streuung der Daten zu beschreiben. Der Median ist auch eine gute Kennzahl, um die zentrale Tendenz zu beschreiben, da er robust gegenüber Ausreissern ist.\n\nBerechne Mittelwert, Median, Spannweite und Standardabweichung des jährlichen Temperaturen in Bern und schaue dir zusätzlich die Ausgabe der summary() Funktion von R an.\n\n\nmean_temp_bern &lt;- mean(jahresdaten$Bern_Mitteltemperatur)\nprint(mean_temp_bern)\n\n[1] 8.715176\n\nmedian_temp_bern &lt;- median(jahresdaten$Bern_Mitteltemperatur)\nprint(median_temp_bern)\n\n[1] 8.666667\n\nrange_temp_bern &lt;- diff(range(jahresdaten$Bern_Mitteltemperatur))\nprint(range_temp_bern)\n\n[1] 3.958333\n\nsd_temp_bern &lt;- sd(jahresdaten$Bern_Mitteltemperatur)\nprint(sd_temp_bern)\n\n[1] 0.8185026\n\nsummary(jahresdaten$Bern_Mitteltemperatur)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  7.092   8.104   8.667   8.715   9.221  11.050 \n\n\nDer Unterschied zwischen Mittelwert und Median (0.05°C) ist sehr klein, was darauf hindeutet, dass die Verteilung der Daten symmetrisch ist. Die Spannweite der Daten beträgt 3.96 °C, was darauf hindeutet, dass die Daten relativ eng um den Mittelwert verteilt sind. Die Standardabweichung beträgt 0.82°C, was darauf hindeutet, dass die Daten relativ homogen um den Mittelwert verteilt sind.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Übung 4: Deskriptive Statistik und Visualisierung</span>"
    ]
  },
  {
    "objectID": "excercises/ex04.html#kontingenztabelle",
    "href": "excercises/ex04.html#kontingenztabelle",
    "title": "Appendix A — Übung 4: Deskriptive Statistik und Visualisierung",
    "section": "A.2 Kontingenztabelle",
    "text": "A.2 Kontingenztabelle\n\nKonvertiere die Spalte mit den Niederschlagssummen in Bern in Klassen, die jeweils 100 mm umfassen (Tipp: z.B. mit round() Funktion für Klassen: &lt;50mm, 50-150mm, 150-250mm, …) Erstelle die Kontingenztabelle für die Anzahl der Regensummen in den 100 mm Klassen in den vier Jahreszeiten (table() Funktion)\n\n                  0 100 200 300 400 500 600\nFruehling(MAM)  ?  ?   ?   ?   ?   ?   ?\nHerbst(SON)     ?  ?   ?   ?   ?   ?   ?\nSommer(JJA)     ?  ?   ?   ?   ?   ?   ?\nWinter(DJF)     ?  ?   ?   ?   ?   ?   ?\nKontingenztabelle mit R erstellen\n\n# 1. Erstelle Klassen für Niederschlagssummen in Bern in 100-mm-Schritten\n# Die Spalte 'Saison' enthält die Jahreszeiten (z.B. 'Fruehling(MAM)', 'Sommer(JJA)')\n# Die Spalte 'Bern_Niederschlagssumme' enthält die Niederschlagssummen\n\n# Klassen für Niederschlagssummen in 100-mm-Schritten erstellen\nmeteodaten$Niederschlag_klassen &lt;- cut(\n  meteodaten$Bern_Niederschlagssumme,\n  breaks = seq(0, max(meteodaten$Bern_Niederschlagssumme, na.rm = TRUE), by = 100),\n  include.lowest = TRUE,\n  right = FALSE\n)\n\n# 2. Erstelle eine Kontingenztabelle\nkontingenz_tabelle &lt;- table(\n  meteodaten$Saison,\n  meteodaten$Niederschlag_klassen\n)\n\n# 3. Zeige die Kontingenztabelle an\nprint(kontingenz_tabelle)\n\n                \n                 [0,100) [100,200) [200,300) [300,400) [400,500) [500,600]\n  Fruehling(MAM)       0        36        60        25         1         1\n  Herbst(SON)          2        38        53        24         6         0\n  Sommer(JJA)          0         7        40        41        31         3\n  Winter(DJF)         14        59        45         5         0         0",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Übung 4: Deskriptive Statistik und Visualisierung</span>"
    ]
  },
  {
    "objectID": "excercises/ex04.html#visualisierung-des-erwärmungstrends",
    "href": "excercises/ex04.html#visualisierung-des-erwärmungstrends",
    "title": "Appendix A — Übung 4: Deskriptive Statistik und Visualisierung",
    "section": "A.3 Visualisierung des Erwärmungstrends",
    "text": "A.3 Visualisierung des Erwärmungstrends\n\nVisualisiert die Erwärmungstrend der Station Bern mit einem Liniendiagramm, indem du die Jahresmitteltemperatur darstellst und die 31-jährige Gleitende Mittel (auch “running mean” genannt z.B. mit der Funktion runmean() aus der Bibliothek “caTools”) hinzufügst.\n\n\nA.3.1 Liniendiagramm mit Gleitendem Mittel\n\n# Bibliothek caTools laden\nlibrary(caTools)\n\n# Berechnung des 31-jährigen gleitenden Mittels (Running Mean)\n# Die Spalte für die Mitteltemperatur in Bern heisst 'Bern_Mitteltemperatur'\ngleitendes_mittel &lt;- runmean(jahresdaten$Bern_Mitteltemperatur, 31, align = \"center\", endrule = \"mean\")\n\n# Liniendiagramm erstellen\nplot(jahresdaten$Jahr, jahresdaten$Bern_Mitteltemperatur, type = \"l\", col = \"blue\",\n     xlab = \"Jahr\", ylab = \"Mitteltemperatur in Bern (°C)\",\n     main = \"Erwärmungstrend der Station Bern mit 31-jährigem Gleitendem Mittel\")\n\n# Hinzufügen der Gleitenden Mittel-Linie (31-jähriges Running Mean)\nlines(jahresdaten$Jahr, gleitendes_mittel, col = \"red\", lwd = 2)\n\n# Legende hinzufügen\nlegend(\"topright\", legend = c(\"Jahresmitteltemperatur\", \"31-jähriges Gleitendes Mittel\"),\n       col = c(\"blue\", \"red\"), lty = 1, lwd = 2)\n\n\n\n\n\n\n\n\nErstelle zusätzlich zwei Abbildungen der Temperaturanomalien wie hier und hier:\n\n\nA.3.2 Warming Stripes\n\n# Bibliothek\nlibrary(ggplot2)\n\n# Berechnung der Abweichung der Mitteltemperatur von der Referenzperiode 1961-1990\njahresdaten$Abweichung &lt;- jahresdaten$Bern_Mitteltemperatur - mean(jahresdaten$Bern_Mitteltemperatur[jahresdaten$Jahr &gt;= 1961 & jahresdaten$Jahr &lt;= 1990])\n\n\n# Erstelle die \"Warming Stripes\"\nggplot(jahresdaten, aes(x = Jahr, y = 1, fill = Abweichung)) +\n  geom_tile() +\n  scale_fill_gradientn(colours = c(\"blue\", \"lightblue\", \"white\", \"orange\", \"red\", \"darkred\")) +\n  theme_void() +  # Entfernt Achsen, Titel etc.\n  theme(legend.position = \"none\") +\n  labs(title = \"Schweizer Temperatur seit 1864\")\n\n\n\n\nWarming Stripes im vergleich zur Referenzperiode 1961-1990\n\n\n\n\n\n\nA.3.3 Barplot der Temperaturanomalien\n\n# Bibliotheken\nlibrary(ggplot2)\n\n# Erstelle einen Barplot, der die Abweichungen darstellt\nggplot(jahresdaten, aes(x = Jahr, y = Abweichung, fill = Abweichung &gt; 0)) +\n  geom_bar(stat = \"identity\", show.legend = FALSE) +\n  scale_fill_manual(values = c(\"blue\", \"red\")) +  # Farben: Blau für kälter, Rot für wärmer\n  theme_minimal() +\n  labs(title = \"Jahres-Temperatur Abweichungen – Bern\",\n       x = \"Jahr\",\n       y = \"Abweichung in °C\") +\n  theme(plot.title = element_text(hjust = 0.5))  # Zentriere den Titel\n\n\n\n\nBarplot der Temperaturanomalien zur Vergleichsperiode 1961–1990. Nach R-Bloggers",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Übung 4: Deskriptive Statistik und Visualisierung</span>"
    ]
  }
]