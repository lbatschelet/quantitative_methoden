[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantitative Methoden",
    "section": "",
    "text": "Quantitative Methoden\nDiese Website dient als Sammlung meiner Vorlesungsnotizen und Übungen für die Vorlesung “Quantitative Methoden” im Herbstsemester 2024.\nDiese Sammlung ist aktuell noch am entstehen.",
    "crumbs": [
      "Quantitative Methoden"
    ]
  },
  {
    "objectID": "grundlagen_R.html",
    "href": "grundlagen_R.html",
    "title": "1  Grundlagen R",
    "section": "",
    "text": "1.1 Grundsätzliches zu R",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#grundsätzliches-zu-r",
    "href": "grundlagen_R.html#grundsätzliches-zu-r",
    "title": "1  Grundlagen R",
    "section": "",
    "text": "1.1.1 Zuweisungsoperator\nIn R werden Werte Variablen mit dem &lt;- Operator zugewiesen.\n\n# Variablen erstellen und Wert zuweisen\na &lt;- 5\n\n# Die Zuweisung kann auch umgekehrt erfolgen\n5 -&gt; b\n\n# Das gleiche funktioniert grundsätzlich aber auch mit dem = Operator\n# Allerdings wird der &lt;- Operator bevorzugt\nc = 10\n\n\n\n1.1.2 Kommentare\nKommentare in R werden mit einem # eingeleitet. Sie können entweder in einer eigenen Zeile stehen oder am Ende einer Codezeile.\n\n# Das ist ein Kommentar\na &lt;- 5 # Das ist auch ein Kommentar\n\n\n\n1.1.3 Ausgabe\nIn R können Werte entweder mit der print() Funktion oder einfach durch Eingabe des Variablennamens ausgegeben werden.\n\n# Ausgabe von Variablen\nprint(a)\n\n[1] 5\n\nb\n\n[1] 5",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#datentypen",
    "href": "grundlagen_R.html#datentypen",
    "title": "1  Grundlagen R",
    "section": "1.2 Datentypen",
    "text": "1.2 Datentypen\nIn R gibt es verschiedene Datentypen. Die wichtigsten sind:\n\nNumerische Werte (z.B. 5, 3.14)\nZeichenketten (Strings) (z.B. \"Hallo Welt\")\nLogische Werte (TRUE, FALSE)\nVektoren (in Python Listen) (z.B. c(1, 2, 3))1\nData Frames (ähnlich wie Tabellen, Mischen von Datentypen möglich)\nMatrizen (ähnlich wie in der Mathematik, keine Mischung von Datentypen möglich)\n\n\n1.2.1 Vektoren\nDa Vektoren eine der grundlegenden Datenstrukturen in R sind, werden wir uns diese genauer ansehen.\nSie können mit der c() Funktion erstellt werden. Vektoren sind grundsätzlich ähnlich wie Objekte vom Typ list in Python. Vektoren können sämtliche Datentypen enthalten, jedoch nur einen Datentyp pro Vektor.\nAuf Vektoren können verschiedene Operationen durchgeführt werden, wie z.B. Addition, Subtraktion, Multiplikation, Division, etc.\n\n# Vektor erstellen\nvectorA &lt;- c(1, 2, 3, 4, 5)\n\n# Länge des Vektors\nlength(vectorA)\n\n[1] 5\n\n# Logischer Vergleich\nvectorA &gt;= 3\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n# Arithmetische Operationen\nvectorA + 5\n\n[1]  6  7  8  9 10\n\n\nWenn wir nun den Vektor vectorA erneut ausgeben, beobachten wir, dass die Operationen nicht den ursprünglichen Vektor verändert haben.\n\nvectorA\n\n[1] 1 2 3 4 5\n\n\nUm den Vektor zu verändern, müssen wir den veränderten Vektor entweder einer neuen Variablen zuweisen oder den Vektor direkt überschreiben.\n\n# Vektor einer neuen Variablen zuweisen\nvectorB &lt;- vectorA + 5\n\n# Vektor ausgeben\nvectorB\n\n[1]  6  7  8  9 10\n\n# Wir können den Vektor auch direkt überschreiben\nvectorA &lt;- vectorA + 5\n\n# Vektor ausgeben\nvectorA\n\n[1]  6  7  8  9 10\n\n\n\n1.2.1.1 Indizierung\nVektoren können indiziert werden, um auf bestimmte Elemente zuzugreifen.\nDie Indizierung beginnt in R bei 1.\n\n# Erstes Element des Vektors\nvectorA[1]\n\n[1] 6\n\n\nWir können auch auf mehrere Elemente gleichzeitig zugreifen. Wenn wir z.B. auf das zweite bis vierte Element des Vektors zugreifen wollen, können wir dies mit dem : Operator tun.\n\n# Zweites bis viertes Element des Vektors\nvectorA[2:4]\n\n[1] 7 8 9\n\n# Alternativ können wir auch einzelne Elemente überspringen\nvectorA[c(1, 3, 5)]\n\n[1]  6  8 10\n\n\n\n\n1.2.1.2 Vektoren konkatenieren\nVektoren können auch konkateniert werden.\n\n# Vektoren erstellen\nvectorA &lt;- c(1, 2, 3, 4, 5)\n\n# Vektoren konkatenieren\nvectorC &lt;- c(vectorA, vectorB)\n\n# Vektor ausgeben\nvectorC\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n1.2.1.3 Vektoren addieren\nVektoren können auch addiert werden. Hierbei werden die Vektoren elementweise addiert.2\n\n# Vektoren addieren\nvectorA + vectorB\n\n[1]  7  9 11 13 15\n\n\n\n\n1.2.1.4 Wichtige Funktionen für Vektoren\n\n\n\n\n\n\n\n\n\nFunktion\nBeschreibung\nBeispiel\nAusgabe\n\n\n\n\nlength()\nLänge des Vektors\nlength(vectorA)\n5\n\n\nsum()\nSumme der Elemente des Vektors\nsum(vectorA)\n15\n\n\nmean()\nDurchschnitt der Elemente des Vektors\nmean(vectorA)\n3\n\n\nvar()\nVarianz der Elemente des Vektors\nvar(vectorA)\n2.5\n\n\nsd()\nStandardabweichung der Elemente des Vektors\nsd(vectorA)\n1.5811388\n\n\nmin()\nMinimum des Vektors\nmin(vectorA)\n1\n\n\nmax()\nMaximum des Vektors\nmax(vectorA)\n5\n\n\nrange()\nBereich des Vektors\nrange(vectorA)\n1, 5\n\n\n\n\n\n\n1.2.2 Data Frames\nIn Data Frames können Vektoren unterschiedlicher Datentypen kombiniert werden. Sie sind ähnlich wie Tabellen in relationalen Datenbanken.\nData Frames können mit der data.frame() Funktion direkt erstellt werden.\n\n# Data Frame erstellen\ndataFrameA &lt;- data.frame(\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\"),\n  age = c(25, 30, 35, 40),\n  married = c(TRUE, FALSE, TRUE, TRUE)\n)\n\n# Data Frame ausgeben\ndataFrameA\n\n     name age married\n1   Alice  25    TRUE\n2     Bob  30   FALSE\n3 Charlie  35    TRUE\n4   David  40    TRUE\n\n\nWichtig ist, dass die Vektoren, die im Data Frame kombiniert werden sollen, die gleiche Länge haben müssen und dass die Vektoren nur einen Datentyp pro Vektor enthalten dürfen.\nWir beobachten auch hier, dass die Vektoren in der Initialisierung des Data Frames wieder mit der c() Funktion erstellt werden.\n\n1.2.2.1 Indizierung\nData Frames können indiziert werden, um auf bestimmte Elemente zuzugreifen.\nDie Indizierung erfolgt ähnlich wie bei Vektoren, jedoch mit dem Unterschied, dass wir zusätzlich auch die gewünschte Spalte angeben müssen. Dies erfolgt durch die Angabe der Zeilen- und Spaltennummer in eckigen Klammern.\nWenn wir eine ganze Zeile ausgeben wollen, geben wir nur die Zeilennummer an und lassen die Spaltennummer weg.\n\n# Erste Zeile des Data Frames\ndataFrameA[1, ]\n\n   name age married\n1 Alice  25    TRUE\n\n# Zweite Zeile und dritte Spalte des Data Frames\ndataFrameA[2, 3]\n\n[1] FALSE\n\n\nWir können mit dem $ Operator auch direkter auf bestimmte Spalten zugreifen.\n\n# Spalte \"name\" des Data Frames\ndataFrameA$name\n\n[1] \"Alice\"   \"Bob\"     \"Charlie\" \"David\"  \n\n\n\n\n1.2.2.2 Auswahl aus Data Frames wieder als Data Frame\nWir können subsetting verwenden, um einen Teil des Data Frames auszuwählen und diesen wieder als Data Frame zu speichern.\n\n# Auswahl der Spalten \"name\" und \"age\" als Data Frame\ndataFrameB &lt;- dataFrameA[, c(\"name\", \"age\")]\n\n# Data Frame ausgeben\ndataFrameB\n\n     name age\n1   Alice  25\n2     Bob  30\n3 Charlie  35\n4   David  40\n\n\n\n\n1.2.2.3 Wichtige Funktionen für Data Frames\n\n\n\n\n\n\n\n\n\nFunktion\nBeschreibung\nBeispiel\nAusgabe\n\n\n\n\nnrow()\nAnzahl der Zeilen des Data Frames\nnrow(dataFrameA)\n4\n\n\nncol()\nAnzahl der Spalten des Data Frames\nncol(dataFrameA)\n3\n\n\ncolnames()\nSpaltennamen des Data Frames\ncolnames(dataFrameA)\nname, age, married\n\n\nrownames()\nZeilennamen des Data Frames\nrownames(dataFrameA)\n1, 2, 3, 4\n\n\nsummary()\nZusammenfassung des Data Frames\nsummary(dataFrameA)\nLength:4 , Class :character , Mode :character , NA, NA, NA, Min. :25.00 , 1st Qu.:28.75 , Median :32.50 , Mean :32.50 , 3rd Qu.:36.25 , Max. :40.00 , Mode :logical , FALSE:1 , TRUE :3 , NA, NA, NA",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#daten-importieren-und-exportieren",
    "href": "grundlagen_R.html#daten-importieren-und-exportieren",
    "title": "1  Grundlagen R",
    "section": "1.3 Daten importieren und exportieren",
    "text": "1.3 Daten importieren und exportieren\nIn R können Daten aus verschiedenen Dateiformaten importiert und exportiert werden. Dazu gehören z.B. CSV-Dateien, Excel-Dateien, JSON-Dateien, etc.\n\n1.3.1 CSV-Dateien\nCSV-Dateien können mit der read.csv() Funktion in R eingelesen werden.\n\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv', sep = ',', header = TRUE)\n\nIn diesem Beispiel wird die CSV-Datei meteodaten_saison.csv eingelesen. Der Parameter sep = ',' gibt an, dass die Werte in der CSV-Datei durch Kommas getrennt sind. Der Parameter header = TRUE gibt an, dass die erste Zeile der CSV-Datei die Spaltennamen enthält.\n\n\n\n\n\n\nAchtung\n\n\n\nDer Pfad zur Datei muss entweder absolut (Bsp.: C:/Users/username/Documents/data.csv) oder relativ zum aktuellen Arbeitsverzeichnis (Bsp.: Data/data.csv) angegeben werden.\nIn aller Regel ist es sinnvoll, den Pfad relativ zum aktuellen Arbeitsverzeichnis anzugeben. Das aktuelle Arbeitsverzeichnis kann in der Terminalkonsole mit dem Befehl getwd() abgefragt werden, und mit dem Befehl setwd() kann das Arbeitsverzeichnis geändert werden.\nEine mögliche Praxis ist es, ein Unterverzeichnis Data im Projektverzeichnis anzulegen und dort alle Daten abzulegen.\n\n\n\n1.3.1.1 Wichtige Funktionen für Datenimport\n\n\nstr(): Zeigt die Struktur des Data Frames an.\n\n\nstr(meteodaten)\n\n'data.frame':   492 obs. of  6 variables:\n $ Jahr                           : int  1901 1901 1901 1901 1902 1902 1902 1902 1903 1903 ...\n $ Saison                         : chr  \"Fruehling(MAM)\" \"Herbst(SON)\" \"Sommer(JJA)\" \"Winter(DJF)\" ...\n $ Bern_Mitteltemperatur          : num  7.73 7.4 16.8 -2.73 7.53 ...\n $ Bern_Niederschlagssumme        : num  92.6 81.6 127 37.5 107.7 ...\n $ GrStBernhard_Mitteltemperatur  : num  -4 -0.8 6.3 -10.6 -3.63 ...\n $ GrStBernhard_Niederschlagssumme: num  164.9 173.6 95.1 118.7 149.4 ...\n\n\n\n\n\nhead(): Zeigt die ersten Zeilen des Data Frames an.\n\n\nhead(meteodaten)\n\n  Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n1 1901 Fruehling(MAM)              7.733333                92.60000\n2 1901    Herbst(SON)              7.400000                81.63333\n3 1901    Sommer(JJA)             16.800000               127.03333\n4 1901    Winter(DJF)             -2.733333                37.46667\n5 1902 Fruehling(MAM)              7.533333               107.73333\n6 1902    Herbst(SON)              7.466667                77.23333\n  GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n1                     -4.000000                       164.90000\n2                     -0.800000                       173.60000\n3                      6.300000                        95.06667\n4                    -10.600000                       118.73333\n5                     -3.633333                       149.36667\n6                     -1.000000                       111.86667\n\n\n\n\n\ntail(): Zeigt die letzten Zeilen des Data Frames an.\n\n\ntail(meteodaten)\n\n    Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n487 2022    Sommer(JJA)             20.000000                79.43333\n488 2022    Winter(DJF)              2.233333                61.56667\n489 2023 Fruehling(MAM)              9.533333                90.83333\n490 2023    Herbst(SON)             11.966667               123.73333\n491 2023    Sommer(JJA)             20.000000                67.70000\n492 2023    Winter(DJF)              2.700000                77.70000\n    GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n487                     10.266667                        85.60000\n488                     -4.966667                        90.00000\n489                     -1.666667                       129.46667\n490                      2.966667                       184.43333\n491                      9.200000                        96.13333\n492                     -5.333333                        76.23333\n\n\n\n\n\nsummary(): Gibt eine Zusammenfassung des Data Frames aus.\n\n\nsummary(meteodaten)\n\n      Jahr         Saison          Bern_Mitteltemperatur\n Min.   :1901   Length:492         Min.   :-4.500       \n 1st Qu.:1931   Class :character   1st Qu.: 4.883       \n Median :1962   Mode  :character   Median : 8.750       \n Mean   :1962                      Mean   : 8.715       \n 3rd Qu.:1993                      3rd Qu.:12.750       \n Max.   :2023                      Max.   :21.100       \n Bern_Niederschlagssumme GrStBernhard_Mitteltemperatur\n Min.   : 15.97          Min.   :-11.2000             \n 1st Qu.: 61.89          1st Qu.: -5.1000             \n Median : 81.07          Median : -1.4000             \n Mean   : 84.42          Mean   : -0.9232             \n 3rd Qu.:102.95          3rd Qu.:  3.2750             \n Max.   :200.03          Max.   : 10.5333             \n GrStBernhard_Niederschlagssumme\n Min.   : 41.97                 \n 1st Qu.:127.68                 \n Median :163.83                 \n Mean   :171.29                 \n 3rd Qu.:206.39                 \n Max.   :450.53                 \n\n\n\n\n\nIndizierung: Mit der Indizierung können bestimmte Zeilen und Spalten des Data Frames ausgewählt werden.\n\n\nmeteodaten[1:10,] # Ersten 10 Zeilen\n\n   Jahr         Saison Bern_Mitteltemperatur Bern_Niederschlagssumme\n1  1901 Fruehling(MAM)              7.733333                92.60000\n2  1901    Herbst(SON)              7.400000                81.63333\n3  1901    Sommer(JJA)             16.800000               127.03333\n4  1901    Winter(DJF)             -2.733333                37.46667\n5  1902 Fruehling(MAM)              7.533333               107.73333\n6  1902    Herbst(SON)              7.466667                77.23333\n7  1902    Sommer(JJA)             16.466667                98.63333\n8  1902    Winter(DJF)             -0.800000                64.63333\n9  1903 Fruehling(MAM)              7.433333                59.20000\n10 1903    Herbst(SON)              8.766667                89.10000\n   GrStBernhard_Mitteltemperatur GrStBernhard_Niederschlagssumme\n1                     -4.0000000                       164.90000\n2                     -0.8000000                       173.60000\n3                      6.3000000                        95.06667\n4                    -10.6000000                       118.73333\n5                     -3.6333333                       149.36667\n6                     -1.0000000                       111.86667\n7                      5.3000000                        80.90000\n8                     -7.4000000                       113.73333\n9                     -4.4666667                       136.56667\n10                    -0.4666667                       169.03333",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#daten-als-.csv--und-.txt-dateien-exportieren",
    "href": "grundlagen_R.html#daten-als-.csv--und-.txt-dateien-exportieren",
    "title": "1  Grundlagen R",
    "section": "1.4 Daten als .csv- und .txt-Dateien exportieren",
    "text": "1.4 Daten als .csv- und .txt-Dateien exportieren\nDaten können mit der write.csv() Funktion als CSV-Dateien und mit der write.table() Funktion als Textdateien exportiert werden.\n\n1.4.1 .csv-Dateien\n\n# CSV-Datei exportieren\nwrite.csv(meteodaten,\n          file = \"meteodaten.csv\",\n          row.names = FALSE)\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nx\nDas Data Frame, das exportiert werden soll.\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden.\n\n\nrow.names\nGibt an, ob die Zeilennummern in der CSV-Datei gespeichert werden sollen.\n\n\n\n\n\n1.4.2 .txt-Dateien\n\n# Textdatei exportieren\nwrite.table(meteodaten, # Das Data Frame, das exportiert werden soll\n            file = \"meteodaten.txt\", # Dateiname und Speicherort\n            sep = \"\\t\", # Tabulator als Trennzeichen\n            eol = \"\\r\", # Zeilenumbruch\n            na = \"NA\", # Wert für fehlende Daten\n            row.names = FALSE,\n            col.names = TRUE)\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nx\nDas Data Frame, das exportiert werden soll.\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden.\n\n\nsep\nTrennzeichen für die Spalten.\n\n\neol\nZeilenumbruch. Kann je nach Betriebssystem erforderlich sein.\n\n\nna\nWert für fehlende Daten.\n\n\nrow.names\nGibt an, ob die Zeilennummern in der Textdatei gespeichert werden sollen.\n\n\ncol.names\nGibt an, ob die Spaltennamen in der Textdatei gespeichert werden sollen.\n\n\n\nWie sonst auch, haben die meisten Parameter Standardwerte, die nicht explizit angegeben werden müssen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#umgang-mit-fehlwerten",
    "href": "grundlagen_R.html#umgang-mit-fehlwerten",
    "title": "1  Grundlagen R",
    "section": "1.5 Umgang mit Fehlwerten",
    "text": "1.5 Umgang mit Fehlwerten\nFehlwerte sind in Datenanalysen ein häufiges Problem. In R werden Fehlwerte standardmässig mit NA (Not Available) dargestellt.\n\n1.5.1 Fehlwerte in Funktionsaufrufen behandeln\nErstellen wir ein Beispiel-Vektor mit Fehlwerten:\n\nvektor_mit_na &lt;- c(1, 2, NA, 4, 5)\n\nWenn wir nun z.B. die Summe des Vektors berechnen, erhalten wir:\n\nsum(vektor_mit_na)\n\n[1] NA\n\n\nDie Ausgabe ist NA, da R nicht weiss, wie es mit dem Fehlwert umgehen soll.\nWir können in diversen Funktionen definieren, wie mit Fehlwerten umgegangen werden soll. Dazu können wir den na.rm Parameter verwenden. (rm = remove) Dieser Parameter ist standardmässig auf FALSE gesetzt.\n\nsum(vektor_mit_na,\n    na.rm = TRUE)\n\n[1] 12\n\n\nDie Ausgabe ist 12, da der Fehlwert ignoriert wird.\nDies funktioniert auch bei anderen Funktionen, wie z.B. mean(), var(), sd(), etc.\n\n\n1.5.2 Fehlwerte im Dateiimport behandeln\nBeim Import von Daten können wir mit dem Parameter na.strings definieren, welche Werte als Fehlwerte interpretiert werden sollen.\n\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv',\n                        sep = ',',\n                        header = TRUE,\n                        na.strings = c(\"NA\", \"N/A\", \"na\"))\n\nIn diesem Beispiel definieren wir, dass die Werte \"NA\", \"N/A\" und \"na\" als Fehlwerte interpretiert werden sollen.\n\n\n1.5.3 Fehlwerte identifizieren\nFehlwerte können mit der is.na() Funktion identifiziert und mit der na.omit() Funktion entfernt werden.\n\n# Fehlwerte identifizieren\nis.na(vektor_mit_na)\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n# Fehlwerte entfernen\nvektor_ohne_na &lt;- na.omit(vektor_mit_na)\n\nDer Vektor ist nun: 1, 2, 4, 5.\n\n1.5.3.1 Überprüfen auf Gleichheit\nFehlwerte müssen mit is.na() überprüft werden, da sie nicht mit == verglichen werden können.3\n\n# Überprüfen auf Gleichheit\nvektor_mit_na == NA\n\n[1] NA NA NA NA NA\n\n# Überprüfen auf Gleichheit mit is.na()\nis.na(vektor_mit_na)\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n\n\n\n\n1.5.4 Fehlwerte ersetzen\nMit der replace() Funktion können Fehlwerte am einfachsten ersetzt werden.\n\n# Vector mit falschen Fehlwerten\nvektor_mit_falschen_na &lt;- c(1, 2, -999, 4, 5)\n\n# Fehlwerte ersetzen\nvektor_mit_korrigierten_na &lt;- replace(vektor_mit_falschen_na,\n                                      vektor_mit_falschen_na == -999,\n                                      NA)\n\nDer Vektor ist nun: 1, 2, NA, 4, 5.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#übungen",
    "href": "grundlagen_R.html#übungen",
    "title": "1  Grundlagen R",
    "section": "1.6 Übungen",
    "text": "1.6 Übungen\nBerechne die Sommer (JJA) Temperaturanomalien zur Referenzperiode 1961 bis 1990 in Bern.\n\n# Daten einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv', sep = ',', header = TRUE)\n\n# Daten filtern\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\n\n# Referenzwert der Periode 1961 bis 1990 berechnen\nreferenzwert &lt;- mean(\n    saison_sommer$Bern_Mitteltemperatur[saison_sommer$Jahr &gt;= 1961\n    & saison_sommer$Jahr &lt;= 1990])\n\n# Sommer (JJA) Temperaturanomalien berechnen und direkt im data frame speichern\nsaison_sommer$Bern_Mitteltemperatur_anomalie &lt;-\n    saison_sommer$Bern_Mitteltemperatur - referenzwert\n\n# Plot erstellen\nplot(saison_sommer$Jahr,\n    saison_sommer$Bern_Mitteltemperatur_anomalie,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Temperaturanomalie (°C)\",\n    main = \"Sommer (JJA) Temperaturanomalien in Bern\")\n\n# null-Linie hinzufügen\nabline(h = 0, col = \"red\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "grundlagen_R.html#footnotes",
    "href": "grundlagen_R.html#footnotes",
    "title": "1  Grundlagen R",
    "section": "",
    "text": "Kleine Anmerkung: Hier wird der Vektor mit der c() Funktion erstellt. Diese Funktion wird verwendet, um Werte zu kombinieren (combine).↩︎\nWenn die Vektoren unterschiedliche Längen haben, wird der kürzere Vektor so oft wiederholt, bis er die Länge des längeren Vektors hat. Wenn die Länge des längeren Vektors kein Vielfaches der Länge des kürzeren Vektors ist, wird eine Warnung ausgegeben.↩︎\nDer Vergleich von Fehlwerten mit == ergibt immer NA, da R nicht weiss, ob der Fehlwert gleich einem anderen Wert ist oder nicht.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grundlagen R</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html",
    "href": "plots_in_R.html",
    "title": "2  Einfache Plots erstellen",
    "section": "",
    "text": "2.0.1 Liniendiagramme\nUm unsere Daten sinnvoller zu plotten müssen wir die Daten zuerst filtern und dann plotten.\nWir diskutieren die verschiedenen Schritte hier später:\n# Subsets der Daten erstellen\nsaison_fruehling &lt;- meteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\nsaison_herbst &lt;- meteodaten[meteodaten$Saison == \"Herbst(SON)\", ]\nsaison_winter &lt;- meteodaten[meteodaten$Saison == \"Winter(DJF)\", ]\n\n# Plot mit den Saisontemperaturen erstellen erstellen\nplot(saison_fruehling$Jahr, saison_fruehling$Bern_Mitteltemperatur,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Saisonale Durchschnittstemperaturen in Bern\",\n    xlim = c(1900, 2020),\n    ylim = c(-5, 35))\n\n# Weitere Linien für andere Jahreszeiten auf den selben Plot hinzufügen\nlines(saison_sommer$Jahr, saison_sommer$Bern_Mitteltemperatur,\n    col = \"red\")\nlines(saison_herbst$Jahr, saison_herbst$Bern_Mitteltemperatur,\n    col = \"green\")\nlines(saison_winter$Jahr, saison_winter$Bern_Mitteltemperatur,\n    col = \"blue\")\n\n# Gestrichelte Horizontale Linie bei 0 hinzufügen\nabline(h = 0, lty = 2)\n\n# Saisonale Mittelwertlinien hinzufügen\nabline(h = mean(saison_fruehling$Bern_Mitteltemperatur),\n    col = \"black\",\n    lty = 3)\nabline(h = mean(saison_sommer$Bern_Mitteltemperatur),\n    col = \"red\",\n    lty = 3)\nabline(h = mean(saison_herbst$Bern_Mitteltemperatur),\n    col = \"green\",\n    lty = 3)\nabline(h = mean(saison_winter$Bern_Mitteltemperatur),\n    col = \"blue\",\n    lty = 3)\n\n# Legende hinzufügen\nlegend(\"topright\",\n    legend = c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\"),\n    col = c(\"black\", \"red\", \"green\", \"blue\"),\n    lty = 1,\n    xpd = TRUE)\nSchauen wir uns nun die verschiedenen Schritte im Detail an.\n# CSV-Datei einlesen\nmeteodaten &lt;- read.csv('Data/meteodaten_saison.csv',\n    sep = ',',\n    header = TRUE)\nDer Parameter sep = ',' gibt an, dass die Werte in der CSV-Datei durch Kommas getrennt sind.\nDer Parameter header = TRUE gibt an, dass die erste Zeile der CSV-Datei die Spaltennamen enthält.\n# Subsets der Daten erstellen\nsaison_fruehling &lt;- meteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\nsaison_sommer &lt;- meteodaten[meteodaten$Saison == \"Sommer(JJA)\", ]\nsaison_herbst &lt;- meteodaten[meteodaten$Saison == \"Herbst(SON)\", ]\nsaison_winter &lt;- meteodaten[meteodaten$Saison == \"Winter(DJF)\", ]\nMit dem == Operator vergleichen wir die Werte auf Gleichheit.\nmeteodaten$Saison == \"Fruehling(MAM)\"\nWir überprüfen also Zeile für Zeile, ob der Wert in der Spalte Saison gleich dem String \"Fruehling(MAM)\" ist. Dies wird in einen boolschen Vektor umgewandelt, der TRUE für Zeilen enthält, die dem Kriterium entsprechen, und FALSE für Zeilen, die es nicht tun.\nBetrachten wir nun eine Klammer weiter aussen, um zu verstehen, was genau wir dem Subset zuweisen.\nmeteodaten[meteodaten$Saison == \"Fruehling(MAM)\", ]\nHier wählen wir alle Zeilen aus dem Data Frame meteodaten aus, in denen die Spalte Saison den Wert \"Fruehling(MAM)\" hat. Da wir nach dem letzten Komma nichts weiter angeben, wählen wir alle Spalten aus.\nUnsere Saisonalen Data Frames enthalten also nicht nur die Temperatur-Mittelwerte aus Bern, sondern auch die Niederschlagswerte von Bern und dem Grossen St. Bernhard. Wir greifen im erstellten Plot nur auf die Temperaturwerte zu.\n# Plot mit den Saisontemperaturen erstellen erstellen\nplot(saison_fruehling$Jahr, saison_fruehling$Bern_Mitteltemperatur,\n    type = \"l\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Saisonale Durchschnittstemperaturen in Bern\",\n    xlim = c(1900, 2020),\n    ylim = c(-5, 35))\nDie plot() Funktion hat viele Parameter, die wir verwenden können, um den Plot anzupassen.\nIn R können wir mit der lines() Funktion weitere Linien zu einem bestehenden Plot hinzufügen.\n# Weitere Linien für andere Jahreszeiten auf den selben Plot hinzufügen\nlines(saison_sommer$Jahr, saison_sommer$Bern_Mitteltemperatur,\n    col = \"red\")\nlines(saison_herbst$Jahr, saison_herbst$Bern_Mitteltemperatur,\n    col = \"green\")\nlines(saison_winter$Jahr, saison_winter$Bern_Mitteltemperatur,\n    col = \"blue\")\nHier müssen wir jeweils nicht mehr ganz so viele Parameter angeben, da wir bereits die Achsenbesschriftung etc. vorgenommen haben. Was wir noch angeben müssen, ist die Farbe der Linie mit dem col Parameter.\n# Gestrichelte Horizontale Linie bei 0 hinzufügen\nabline(h = 0, lty = 2)\nMit der abline() Funktion können wir Linien zu einem Plot hinzufügen. Mit dem h Parameter geben wir die y-Position der Linie an, und mit dem lty Parameter geben wir den Linientyp an. Hier verwenden wir lty = 2, um eine gestrichelte Linie zu zeichnen.\n# Saisonale Mittelwertlinien hinzufügen\nabline(h = mean(saison_fruehling$Bern_Mitteltemperatur),\n    col = \"black\",\n    lty = 3)\nabline(h = mean(saison_sommer$Bern_Mitteltemperatur),\n    col = \"red\",\n    lty = 3)\nabline(h = mean(saison_herbst$Bern_Mitteltemperatur),\n    col = \"green\",\n    lty = 3)\nabline(h = mean(saison_winter$Bern_Mitteltemperatur),\n    col = \"blue\",\n    lty = 3)\nHier fügen wir gestrichelte Linien für die Mittelwerte der Temperatur für jede Jahreszeit hinzu. Wir verwenden die mean() Funktion, um direkt im Aufruf den Mittelwert zu berechnen.\n# Legende hinzufügen\nlegend(\"topright\",\n    legend = c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\"),\n    col = c(\"black\", \"red\", \"green\", \"blue\"),\n    lty = 1,\n    xpd = TRUE)\nMit der legend() Funktion können wir eine Legende zu einem Plot hinzufügen. Wir geben die Position der Legende mit dem topright Parameter an. Mit dem legend Parameter geben wir die Beschriftungen für die Linien an. Mit dem col Parameter geben wir die Farben der Linien an. Mit dem lty Parameter geben wir den Linientyp an. Mit dem xpd Parameter geben wir an, ob die Legende ausserhalb des Plots sein soll.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#scatterplots-und-aggregate-funktion",
    "href": "plots_in_R.html#scatterplots-und-aggregate-funktion",
    "title": "2  Einfache Plots erstellen",
    "section": "2.1 Scatterplots und aggregate()-Funktion",
    "text": "2.1 Scatterplots und aggregate()-Funktion\nWenn wir von unseren nach Jahreszeiten sortierten Daten nun bspw. den Durchschnitt der Temperaturwerte pro Jahr berechnen wollen, können wir die aggregate() Funktion verwenden.\n\n# Durchschnittstemperatur pro Jahr berechnen\ndurchschnittstemperatur_pro_jahr &lt;- aggregate(Bern_Mitteltemperatur ~ Jahr,\n    data = meteodaten,\n    FUN = mean)\n\n# Plot erstellen\nplot(durchschnittstemperatur_pro_jahr$Jahr,\n    durchschnittstemperatur_pro_jahr$Bern_Mitteltemperatur,\n    type = \"p\",\n    xlab = \"Jahr\",\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur pro Jahr in Bern\")\n\n# Lineares Modell (lineare Regression) erstellen\ntrend &lt;- lm(Bern_Mitteltemperatur ~ Jahr,\n    data = durchschnittstemperatur_pro_jahr)\n\n# Trendlinie hinzufügen\nabline(trend,\n    col = \"red\",\n    lwd = 2)  # Die Farbe und Dicke der Linie anpassen\n\n\n\n\n\n\n\n\nDie aggregate() Funktion nimmt vier Parameter:\n\nDie Spalte, nach der aggregiert werden soll (Bern_Mitteltemperatur).\nDie Spalte, nach der gruppiert werden soll (Jahr).\nDie Daten, auf die die Funktion angewendet werden soll (meteodaten).\nDie Funktion, die auf die aggregierten Werte angewendet werden soll (mean).\n\nDer ~-Operator wird in R verwendet, um die linke Seite von der rechten Seite zu trennen. In diesem Fall bedeutet dies, dass wir die Spalte Bern_Mitteltemperatur nach der Spalte Jahr aggregieren wollen.\nZusätzlich haben wir hier noch eine Trendlinie hinzugefügt. Dazu haben wir ein lineares Modell mit der lm() Funktion erstellt und die Trendlinie mit der abline() Funktion hinzugefügt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#boxplots-und-mehrere-plots-in-einem-diagramm",
    "href": "plots_in_R.html#boxplots-und-mehrere-plots-in-einem-diagramm",
    "title": "2  Einfache Plots erstellen",
    "section": "2.2 Boxplots und mehrere Plots in einem Diagramm",
    "text": "2.2 Boxplots und mehrere Plots in einem Diagramm\nWir wollen nun für die Temperaturen und Niederschlagswerte in Bern und auf dem Grossen St. Bernhard Boxplots erstellen und diese in einem Diagramm nebeneinander plotten. Zusätzlich wollen wir die Daten Zeitlich bis ins Jahr 1980 beschränken. Auch dieser Code enthält einige zusätzliche und neue Schritte, welche wir uns anschliessend genauer ansehen.\n\n# Definiere neue Kategorien-Namen und die gewünschte Reihenfolge\nneue_namen &lt;- c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\")\nalte_namen &lt;- c(\"Fruehling(MAM)\", \"Sommer(JJA)\", \"Herbst(SON)\", \"Winter(DJF)\")\n\n# Konvertiere 'Saison' in einen Faktor mit den neuen Namen und der gewünschten Reihenfolge\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = alte_namen,\n                            labels = neue_namen)\n\n# Mehrere Plots in einem Diagramm\npar(mfrow = c(2, 2), # 2 Zeilen und 2 Spalten\n    mar = c(4, 4, 2, 1), # verkleinert die Ränder\n    oma = c(0, 0, 4, 0), # fügt Platz für den Titel hinzu\n    cex = 0.8) # verkleinert die Schriftgrösse\n\n# Boxplots erstellen\nboxplot(Bern_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Bern\")\n\nboxplot(GrStBernhard_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Gr. St. Bernhard\")\n\nboxplot(Bern_Niederschlagssumme ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(0, 400),\n    ylab = \"Niederschlag in mm\",\n    main = \"Niederschlag Bern\")\n\nboxplot(GrStBernhard_Niederschlagssumme ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(0, 400),\n    ylab = \"Niederschlag in mm\",\n    main = \"Niederschlag Gr. St. Bernhard\")\n\n# Gesamte Überschrift für alle Plots hinzufügen\ntitle(\"Klimadaten in Bern und auf dem Grossen St. Bernhard\", outer = TRUE)\n\n\n\n\n\n\n\n\nSchauen wir uns die verschiedenen Schritte im Detail an:\n\nDefiniere neue Kategorien-Namen und die gewünschte Reihenfolge: Die Kategorien-Namen haben bisher die Form Fruehling(MAM), Sommer(JJA), Herbst(SON), Winter(DJF). Um die Lesbarkeit zu verbessern und etwas kürzere Namen zu verwenden, definieren wir neue Namen. In einem nächsten Schritt konvertieren wir die Spalte Saison in einen Faktor1 mit den neuen Namen und der gewünschten Reihenfolge.\n\n\nneue_namen &lt;- c(\"Frühling\", \"Sommer\", \"Herbst\", \"Winter\")\nalte_namen &lt;- c(\"Fruehling(MAM)\",\n                \"Sommer(JJA)\",\n                \"Herbst(SON)\",\n                \"Winter(DJF)\")\n\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = alte_namen,\n                            labels = neue_namen)\n\nWir verwenden die factor() Funktion, um die Spalte Saison, die aktuell als Strings vorliegt, in einen Faktor zu konvertieren. Mit dem levels Parameter geben wir die Reihenfolge der vorhandenen Werte in den Daten an – hier die alten Namen, da diese in den Rohdaten stehen. Der labels Parameter definiert die neuen Namen, die im Plot oder bei Ausgaben angezeigt werden sollen.\nWichtig zu verstehen ist, dass die Umwandlung mit factor() nicht die zugrunde liegenden Daten ändert, sondern nur die Art und Weise, wie die Kategorien dargestellt werden. Die ursprünglichen Werte (also die alten Namen) bleiben im Data Frame erhalten2, aber R verwendet die neuen Labels, um diese Werte im Plot oder bei der Ausgabe anders zu präsentieren.\n\nMehrere Plots in einem Diagramm: Mit der par() Funktion können wir das Layout und die Platzierung der Plots anpassen.\n\n\nMit dem mfrow Parameter geben wir an, wie viele Zeilen und Spalten von Plots wir haben wollen. Hier haben wir 2 Zeilen und 2 Spalten.\nMit dem mar Parameter können wir die Ränder des Plots anpassen.\nMit dem oma Parameter können wir Platz für den Titel des gesamten Diagramms hinzufügen.\nMit dem cex Parameter können wir die Schriftgrösse anpassen.\n\n\npar(mfrow = c(2, 2), # 2 Zeilen und 2 Spalten\n    mar = c(4, 4, 2, 1), # verkleinert die Ränder\n    oma = c(0, 0, 4, 0), # fügt Platz für den Titel hinzu\n    cex = 0.8) # verkleinert die Schriftgrösse\n\n\nBoxplots erstellen: Wir erstellen Boxplots für die Durchschnittstemperaturen und Niederschlagssummen in Bern und auf dem Grossen St. Bernhard.\n\nZusätzlich beschränken wir die Daten auf die Jahre bis 1980.\n\nboxplot(Bern_Mitteltemperatur ~ Saison,\n    data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n    ylim = c(-10, 20),\n    ylab = \"Durchschnittstemperatur in °C\",\n    main = \"Durchschnittstemperatur Bern\")\n\nWir beachten auch hier wieder die Verwendung des ~-Operators, um die linke Seite von der rechten Seite zu trennen. In diesem Fall bedeutet dies, dass wir die Spalte Bern_Mitteltemperatur nach der Spalte Saison gruppieren wollen.\nWir verwenden die ylim Parameter, um die y-Achse auf einen bestimmten Bereich zu beschränken. Dies ist nützlich, um die Plots besser vergleichen zu können.\nDie Selelektion der Daten erflogt im data Parameter. Hier wählen wir nur die Daten bis ins Jahr 1980 aus.\n\nGesamte Überschrift für alle Plots hinzufügen: Wir fügen eine Überschrift für alle Plots hinzu.\n\n\ntitle(\"Klimadaten in Bern und auf dem Grossen St. Bernhard\", outer = TRUE)\n\nDer outer Parameter gibt an, dass die Überschrift über allen Plots platziert werden soll.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#grafiken-speichern",
    "href": "plots_in_R.html#grafiken-speichern",
    "title": "2  Einfache Plots erstellen",
    "section": "2.3 Grafiken speichern",
    "text": "2.3 Grafiken speichern\nGrafiken können entweder in RStudio unter dem Reiter “Export” … “Save Plot as PDF” oder “…Image” gespeichert werden.\nAlternativ können mit den Funktionen pdf(), jpeg() und png() Grafiken direkt in R gespeichert werden.\n\n# PDF-Datei erstellen\npdf(file = \"boxplots.pdf\",\n    width = 9,\n    height = 4.5) # Grösse des PDFs in Inch\n\n# Boxplot aus der vorherigen Sektion erstellen\nboxplot(Bern_Mitteltemperatur ~ Saison,\n        data = meteodaten[meteodaten$Jahr &lt;= 1980, ],\n        ylim = c(-10, 20),\n        ylab = \"Durchschnittstemperatur in °C\",\n        main = \"Durchschnittstemperatur Bern\")\n\n# PDF-Datei schliessen\ndev.off()\n\n\n\n\n\n\n\n\nParameter\nBeschreibung\n\n\n\n\nfile\nDateiname und Speicherort. Auch hier können absolute und relative Dateipfade verwendet werden. Wichtig ist die entsprechende Dateieindung (.pdf, .jpeg oder .png) anzugeben.\n\n\nwidth\nBreite des Plots in Inch.\n\n\nheight\nHöhe des Plots in Inch.\n\n\ndev.off()\nIst kein eigentlicher Parameter, aber ist am Ende jeder der Funktionen benötigt, um den Export zu beenden.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "plots_in_R.html#footnotes",
    "href": "plots_in_R.html#footnotes",
    "title": "2  Einfache Plots erstellen",
    "section": "",
    "text": "Ein Faktor ist ein Datentyp in R, der kategorische Daten repräsentiert. Faktoren werden verwendet, um Daten zu kategorisieren und zu ordnen.↩︎\nWenn eine Spalte mit factor() bearbeitet wird, wird sie intern in diskrete Kategorien umgewandelt, jedoch ohne die ursprünglichen Daten zu überschreiben. Der levels Parameter bezieht sich auf die originalen Datenwerte, um sicherzustellen, dass R die Daten korrekt interpretiert. Die labels hingegen ändern nur, wie diese Daten für den Benutzer angezeigt werden. Dadurch bleibt der Inhalt des Data Frames unverändert, aber die Darstellung der Werte wird angepasst. Das ist nützlich, wenn man die Rohdaten beibehalten will, jedoch für Visualisierungen oder Präsentationen eine klarere oder kürzere Bezeichnung verwenden möchte.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einfache Plots erstellen</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html",
    "href": "packages_and_libraries.html",
    "title": "3  Packages und Libraries",
    "section": "",
    "text": "3.1 Pakete installieren\nPakete können mit der Funktion install.packages() installiert werden. Zum Beispiel:\ninstall.packages(\"ggplot2\")\nUm Skripte und Notebooks portabel zu halten, ist es sinnvoll, die Installation von fehlenden Paketen am Anfang des Skripts oder Notebooks zu platzieren.\nif (!require(\"ggplot2\")) {\n  install.packages(\"ggplot2\")\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#pakete-laden",
    "href": "packages_and_libraries.html#pakete-laden",
    "title": "3  Packages und Libraries",
    "section": "3.2 Pakete laden",
    "text": "3.2 Pakete laden\nPakete können mit der Funktion library() geladen werden. Zum Beispiel:\n\nlibrary(ggplot2)\n\nDie meisten Pakete haben eine Vielzahl von Funktionen, die genutzt werden können. Es ist ratsam, die Dokumentation des Pakets zu lesen, um die verfügbaren Funktionen und deren Anwendung zu verstehen. Die Dokumentation eines Pakets kann mit dem Befehl ? aufgerufen werden. Zum Beispiel:\n\n?ggplot2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#häufig-genutzte-pakete",
    "href": "packages_and_libraries.html#häufig-genutzte-pakete",
    "title": "3  Packages und Libraries",
    "section": "3.3 Häufig genutzte Pakete",
    "text": "3.3 Häufig genutzte Pakete\nEinige der am häufigsten genutzten Pakete in R sind:\n\nggplot2: Ein Paket zur Erstellung von ansprechenden und aussagekräftigen Grafiken.\ndplyr: Ein Paket zur Datenmanipulation und -aggregation.\ntidyr: Ein Paket zur Datenbereinigung und -umformung.\nreadr: Ein Paket zur Einlesung von Daten aus verschiedenen Dateiformaten.\nstringr: Ein Paket zur Arbeit mit Zeichenketten.\nlubridate: Ein Paket zur Arbeit mit Datum und Uhrzeit.\ncaret: Ein Paket zur Erstellung von Modellen und zur Modellauswertung.\ntidyverse: Ein Paket, das eine Sammlung von Paketen für die Datenanalyse in R bereitstellt.\n\nEs gibt viele weitere Pakete, die für spezifische Anwendungen und Analysen entwickelt wurden. Es ist ratsam, die Dokumentation der Pakete zu lesen, um die verfügbaren Funktionen und deren Anwendung zu verstehen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "packages_and_libraries.html#beispiel-einbinden-des-ggplot2-pakets",
    "href": "packages_and_libraries.html#beispiel-einbinden-des-ggplot2-pakets",
    "title": "3  Packages und Libraries",
    "section": "3.4 Beispiel: Einbinden des ggplot2 Pakets",
    "text": "3.4 Beispiel: Einbinden des ggplot2 Pakets\nAn einem einfachen Beispiel sehen wir, wie mit Hilfe der Pakete ggplot2 und plotly ein interaktives Diagramm erstellt werden kann.\n\n# Bibliotheken laden\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Daten für den Plot vorbereiten\n# Konvertiere die Spalte Saison in einen einfacheren Faktor für die Darstellung\nmeteodaten$Saison &lt;- factor(meteodaten$Saison,\n                            levels = c(\"Fruehling(MAM)\",\n                                       \"Sommer(JJA)\",\n                                       \"Herbst(SON)\",\n                                       \"Winter(DJF)\"),\n                            labels = c(\"Frühling\",\n                                       \"Sommer\",\n                                       \"Herbst\",\n                                       \"Winter\"))\n\n# Plot mit ggplot2 erstellen\ngg &lt;- ggplot(meteodaten, aes(x = Jahr,\n        y = Bern_Mitteltemperatur,\n        color = Saison)) +\n    geom_line(linewidth = 1.2) +  # Linienbreite anpassen\n    geom_hline(yintercept = 0,\n        linetype = \"dashed\") +  # Horizontale Linie bei 0\n    labs(title = \"Saisonale Durchschnittstemperaturen in Bern\",\n        x = \"Jahr\",\n        y = \"Durchschnittstemperatur in °C\") +\n    theme_minimal() +  # Minimalistisches Theme für einen klaren Look\n    scale_color_manual(values = c(\"Frühling\" = \"green\",\n                                  \"Sommer\" = \"red\",\n                                  \"Herbst\" = \"orange\",\n                                  \"Winter\" = \"blue\")) +  # Farben anpassen\n    theme(plot.title = element_text(hjust = 0.5,\n        size = 16))  # Zentriere Titel und passe die Schriftgröße an\n\n# Plot interaktiv machen mit plotly\ngg_interaktiv &lt;- ggplotly(gg)\n\n# Interaktiver Plot anzeigen\ngg_interaktiv\n\n\n\nInteraktives Diagramm der saisonalen Durchschnittstemperaturen in Bern",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages und Libraries</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html",
    "href": "loops_and_functions.html",
    "title": "4  Schlaufen und Funktionen",
    "section": "",
    "text": "4.1 if() und else()\nMit if() und else() können Bedingungen in R überprüft und entsprechende Aktionen ausgeführt werden. Die Syntax ist wie folgt:\nif (Bedingung) {\n  # Aktion, wenn die Bedingung TRUE ist\n} else {\n  # Aktion, wenn die Bedingung FALSE ist\n}\nZum Beispiel:\nx &lt;- 10\nif (x &gt; 5) {\n  print(paste(x, \"ist grösser als 5\"))\n} else {\n  print(\"x ist kleiner oder gleich 5\")\n}\n\n[1] \"10 ist grösser als 5\"\nHier verwenden wir zusätzlich die Funktion paste(), um Text und Variablen zu kombinieren. Dies ist ohne nicht direkt möglich.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#if-und-else",
    "href": "loops_and_functions.html#if-und-else",
    "title": "4  Schlaufen und Funktionen",
    "section": "",
    "text": "4.1.1 ifelse() als Vektoroperation\nifelse() ist eine Funktion, die eine Bedingung auf einen Vektor anwendet und basierend auf der Bedingung Werte zurückgibt. Die Syntax ist wie folgt:\n\nifelse(Bedingung, Wert_wenn_TRUE, Wert_wenn_FALSE)\n\nZum Beispiel:\n\nvectorA &lt;- c(1, 2, 3, 4, 5)\nifelse(vectorA == 3, \"Drei\", \"Nicht Drei\")\n\n[1] \"Nicht Drei\" \"Nicht Drei\" \"Drei\"       \"Nicht Drei\" \"Nicht Drei\"",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#schleifen",
    "href": "loops_and_functions.html#schleifen",
    "title": "4  Schlaufen und Funktionen",
    "section": "4.2 Schleifen",
    "text": "4.2 Schleifen\nSchleifen sind nützlich, um eine bestimmte Aktion mehrmals auszuführen. In R gibt es verschiedene Arten von Schleifen, darunter for, while und repeat.\n\n4.2.1 for Schleife\nDie for Schleife wird verwendet, um eine Aktion für jedes Element in einer Sequenz auszuführen. Die Syntax ist wie folgt:\n\nfor (Element in Sequenz) {\n  # Aktion, die für jedes Element ausgeführt wird\n}\n\nZum Beispiel:\n\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nSchleifen mit Laufindex\nLaufindexe können in R auch ausserhalb der Schleife definiert werden. Zum Beispiel:\n\noriginal_vector &lt;- c(1, 2, 3, 4, 5)\nresult_vector &lt;- vector() # Leerer Vektor für das Ergebnis\n\n# Laufindex definieren\nj &lt;- 1\n\nfor (i in original_vector) {\n  result_vector[j] &lt;- i * 2\n  j &lt;- j + 1\n}\n\nresult_vector\n\n[1]  2  4  6  8 10\n\n\nBemerkung: aus Python kennen wir j++ oder j += 1 um den Laufindex zu erhöhen. In R gibt es keinen solchen Shortcut.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  },
  {
    "objectID": "loops_and_functions.html#eigene-funktionen",
    "href": "loops_and_functions.html#eigene-funktionen",
    "title": "4  Schlaufen und Funktionen",
    "section": "4.3 Eigene Funktionen",
    "text": "4.3 Eigene Funktionen\nFunktionen sind nützlich, um wiederkehrende Aktionen zu kapseln und zu abstrahieren. In R können eigene Funktionen mit dem function Schlüsselwort definiert werden. Die Syntax ist wie folgt:\n\nfunktion_name &lt;- function(Parameter1, Parameter2, ...) {\n  # Aktionen, die die Funktion ausführt\n  return(Ergebnis)\n}\n\nZum Beispiel:\nWir schreiben eine Funktion, die die Summe der Quadrate von zwei Zahlen berechnet.\n\nsumme_quadrate &lt;- function(x, y) {\n  summe &lt;- x^2 + y^2\n  return(summe)\n}\n\nDie Funktion kann dann wie folgt aufgerufen werden:\n\nsumme_quadrate(3, 4)\n\n[1] 25",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Schlaufen und Funktionen</span>"
    ]
  }
]